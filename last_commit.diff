commit a76a8f3354b924042258970bb35204aa46e4ee3e
Author: Mehul Fadnavis <mehul.fadnavis@grabtaxi.com>
Date:   Wed Jan 28 17:12:44 2026 +0800

    feat: Implement Daemon Architecture & Consolidate Output Channels and Fix Cancel Button
    
    - **Daemon Architecture**:
      - Added `src/server/` containing the standalone Daemon implementation for query execution.
      - Added `src/services/DaemonClient.ts` to communicate with the Daemon.
      - Updated `QueryExecutor` to use DaemonClient for execution.
      - Updated `ServiceContainer` to register Daemon services.
    
    - **Logging Consolidation**:
      - Refactored `extension.ts` and `ResultsViewProvider.ts` to use a singleton `Logger`.
      - Consolidated all logs to "SQL Preview" output channel.
    
    - **Bug Fixes**:
      - Fixed "Cancel Query" button in Webview by replacing inline `onclick` with programmatic `addEventListener` (CSP compliance).
      - Fixed logic in `ResultsViewProvider` (restored missing `log`, `closeOtherTabs`, `getLastActiveFileUri` methods).
      - Fixed syntax error and selector typo in `resultsView.js`.
    
    - **Documentation**:
      - Added RFC documents for architecture decisions.

diff --git a/docs/implementations/RFC-002-standalone-browser-ui.md b/docs/implementations/RFC-002-standalone-browser-ui.md
new file mode 100644
index 0000000..cbac38e
--- /dev/null
+++ b/docs/implementations/RFC-002-standalone-browser-ui.md
@@ -0,0 +1,346 @@
+# RFC-002: Standalone Browser UI for Claude Code Integration
+
+**Status**: Proposed
+**Created**: 2026-01-28
+
+## Goal
+
+Enable SQL Preview to be used with Claude Code (or any MCP client) outside of VS Code/Cursor by creating a standalone server with a browser-based results UI.
+
+## Problem Statement
+
+Currently, SQL Preview is tightly coupled to VS Code:
+
+- The MCP server only runs when the VS Code extension is active
+- Query results are displayed in a VS Code webview
+- Configuration is stored in VS Code settings
+
+This limits usage to scenarios where the user has VS Code open. Users of Claude Code in a standalone terminal cannot:
+
+1. Execute SQL queries via the MCP tools
+2. View query results in a visual data grid
+
+## Proposed Architecture
+
+```
+┌─────────────────────────────────────────────────────────────┐
+│  sql-preview-server (standalone Node.js process)           │
+│                                                             │
+│  ┌───────────────┐        ┌────────────────────────────┐   │
+│  │  MCP Server   │        │  HTTP Server               │   │
+│  │  (stdio)      │        │  - Static UI files         │   │
+│  │               │        │  - REST API                │   │
+│  │  Tools:       │        │  - WebSocket (live push)   │   │
+│  │  - run_query  │        │                            │   │
+│  │  - list_tabs  │        │  Endpoints:                │   │
+│  │  - get_tab    │        │  GET  /           → UI     │   │
+│  │               │        │  GET  /api/tabs   → JSON   │   │
+│  │               │        │  WS   /ws         → push   │   │
+│  └───────┬───────┘        └─────────────┬──────────────┘   │
+│          │                              │                   │
+│          └──────────┬───────────────────┘                   │
+│                     ▼                                       │
+│          ┌─────────────────────┐                            │
+│          │   Core Engine       │                            │
+│          │   - QueryExecutor   │                            │
+│          │   - ResultsStore    │                            │
+│          │   - TabManager      │                            │
+│          └──────────┬──────────┘                            │
+│                     │                                       │
+│          ┌─────────────────────┐                            │
+│          │   Connectors        │                            │
+│          │   - Trino           │                            │
+│          │   - PostgreSQL      │                            │
+│          │   - SQLite          │                            │
+│          └─────────────────────┘                            │
+└─────────────────────────────────────────────────────────────┘
+          │                              │
+          ▼                              ▼
+    Claude Code                    Browser Window
+    (stdio MCP)                    http://localhost:3000
+```
+
+## Components
+
+### 1. Package Structure
+
+```
+sql-preview/
+├── src/                              # Existing VS Code extension
+├── packages/
+│   ├── core/                         # Shared core (extracted)
+│   │   ├── connectors/
+│   │   │   ├── base/
+│   │   │   │   ├── IConnector.ts
+│   │   │   │   └── ConnectorRegistry.ts
+│   │   │   ├── trino/
+│   │   │   ├── postgres/
+│   │   │   └── sqlite/
+│   │   ├── execution/
+│   │   │   └── QueryExecutor.ts
+│   │   ├── store/
+│   │   │   ├── TabManager.ts
+│   │   │   └── ResultsStore.ts
+│   │   └── index.ts
+│   │
+│   ├── mcp-server/                   # Standalone MCP server
+│   │   ├── src/
+│   │   │   ├── index.ts              # Entry point (stdio + HTTP)
+│   │   │   ├── McpHandler.ts         # MCP tool definitions
+│   │   │   ├── HttpServer.ts         # Express server
+│   │   │   ├── WebSocketManager.ts   # Live updates
+│   │   │   └── ConfigLoader.ts       # File/env config
+│   │   ├── bin/
+│   │   │   └── sql-preview-server    # CLI entry
+│   │   └── package.json
+│   │
+│   └── web-ui/                       # Browser UI
+│       ├── src/
+│       │   ├── App.tsx
+│       │   ├── components/
+│       │   │   ├── ResultsGrid.tsx   # AG Grid wrapper
+│       │   │   ├── TabBar.tsx
+│       │   │   ├── Toolbar.tsx
+│       │   │   └── StatusBar.tsx
+│       │   ├── hooks/
+│       │   │   ├── useWebSocket.ts
+│       │   │   └── useTabs.ts
+│       │   └── styles/
+│       │       └── theme.css
+│       ├── index.html
+│       └── package.json
+│
+└── package.json                      # Workspace root
+```
+
+### 2. MCP Server (stdio transport)
+
+The standalone server uses **stdio transport** instead of SSE, which is the preferred method for Claude Code CLI integration.
+
+```typescript
+// packages/mcp-server/src/index.ts
+#!/usr/bin/env node
+import { Server } from '@modelcontextprotocol/sdk/server/index.js';
+import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
+import { HttpServer } from './HttpServer.js';
+import { QueryExecutor } from '@sql-preview/core';
+
+const server = new Server(
+  { name: 'sql-preview', version: '1.0.0' },
+  { capabilities: { tools: {}, resources: {} } }
+);
+
+// Start HTTP server for browser UI
+const httpServer = new HttpServer(queryExecutor, tabManager);
+await httpServer.start(3000);
+
+// Connect MCP via stdio
+const transport = new StdioServerTransport();
+await server.connect(transport);
+```
+
+### 3. Configuration
+
+Replace VS Code settings with a configuration file and environment variables:
+
+```json
+// ~/.sql-preview.json
+{
+  "connections": {
+    "default": {
+      "type": "trino",
+      "host": "trino.example.com",
+      "port": 443,
+      "user": "analyst",
+      "catalog": "hive",
+      "schema": "default",
+      "ssl": true
+    },
+    "local-pg": {
+      "type": "postgres",
+      "host": "localhost",
+      "port": 5432,
+      "user": "postgres",
+      "database": "myapp"
+    }
+  },
+  "defaultConnection": "default",
+  "ui": {
+    "port": 3000,
+    "autoOpen": true,
+    "maxRows": 10000
+  },
+  "safeMode": true
+}
+```
+
+Environment variable overrides:
+
+```bash
+SQL_PREVIEW_HOST=trino.example.com
+SQL_PREVIEW_USER=analyst
+SQL_PREVIEW_PASSWORD=secret
+SQL_PREVIEW_UI_PORT=3000
+```
+
+### 4. Browser UI
+
+The web UI reuses the existing AG Grid implementation from the VS Code webview:
+
+**Features:**
+
+- Tabbed interface for multiple query results
+- AG Grid with sorting, filtering, column resizing
+- CSV export
+- Copy to clipboard (cell, row, range)
+- Dark/light theme support
+- Real-time updates via WebSocket
+
+**Communication Flow:**
+
+```
+┌─────────────┐     WebSocket      ┌─────────────┐
+│  Browser    │ ◄────────────────► │  Server     │
+│             │                    │             │
+│  Events:    │                    │  Pushes:    │
+│  - request  │                    │  - new_tab  │
+│    tabs     │                    │  - update   │
+│  - export   │                    │  - error    │
+│  - copy     │                    │  - progress │
+└─────────────┘                    └─────────────┘
+```
+
+### 5. MCP Tools
+
+| Tool         | Description          | Parameters                                               |
+| ------------ | -------------------- | -------------------------------------------------------- |
+| `run_query`  | Execute SQL query    | `sql: string`, `connection?: string`, `newTab?: boolean` |
+| `list_tabs`  | List all result tabs | none                                                     |
+| `get_tab`    | Get tab data by ID   | `tabId: string`                                          |
+| `close_tab`  | Close a result tab   | `tabId: string`                                          |
+| `export_csv` | Export tab to CSV    | `tabId: string`, `path: string`                          |
+
+### 6. Auto-Open Browser
+
+When a query completes, optionally open the results in the default browser:
+
+```typescript
+import open from 'open';
+
+if (config.ui.autoOpen) {
+  await open(`http://localhost:${config.ui.port}?tab=${tabId}`);
+}
+```
+
+## User Experience
+
+### Installation
+
+```bash
+# Install globally
+npm install -g @sql-preview/server
+
+# Or use npx
+npx @sql-preview/server
+```
+
+### Usage with Claude Code
+
+```bash
+# Add MCP server to Claude Code
+claude mcp add sql-preview -- sql-preview-server
+
+# Or with npx
+claude mcp add sql-preview -- npx @sql-preview/server
+```
+
+### Typical Session
+
+```bash
+# Terminal: Start Claude Code
+$ claude
+
+You: Show me the top 10 customers by revenue from the analytics database
+
+# Claude calls run_query tool via MCP
+# Browser opens http://localhost:3000 with results
+# Claude receives data and can discuss it
+
+Claude: Here are the top 10 customers by revenue:
+| customer_id | name           | total_revenue |
+|-------------|----------------|---------------|
+| 1042        | Acme Corp      | $2,450,000    |
+| ...         | ...            | ...           |
+
+The results are also visible in your browser at http://localhost:3000
+```
+
+## Migration Path
+
+### Phase 1: Extract Core
+
+1. Move connectors to `packages/core/connectors/`
+2. Move `QueryExecutor` to `packages/core/execution/`
+3. Create `TabManager` that works without VS Code
+4. Update VS Code extension to import from `@sql-preview/core`
+
+### Phase 2: Standalone MCP Server
+
+1. Create `packages/mcp-server/` with stdio transport
+2. Implement configuration loader (file + env vars)
+3. Add HTTP server for REST API
+4. Implement WebSocket for live updates
+
+### Phase 3: Browser UI
+
+1. Create `packages/web-ui/` with Vite + React
+2. Port AG Grid setup from `webviews/results/`
+3. Implement WebSocket client
+4. Add theme support (reuse existing CSS variables)
+
+### Phase 4: Polish & Publish
+
+1. Add CLI argument parsing (`--port`, `--config`, `--no-ui`)
+2. Add connection testing command
+3. Write documentation
+4. Publish to npm as `@sql-preview/server`
+
+## Alternatives Considered
+
+### 1. Keep SSE Transport Only
+
+**Rejected**: SSE is deprecated in MCP spec. Claude Code works better with stdio for local tools.
+
+### 2. Electron App
+
+**Deferred**: Adds significant complexity. Browser UI is simpler and sufficient for most use cases.
+
+### 3. Terminal UI (TUI)
+
+**Deferred**: Could be added later using `blessed` or `ink`. Data tables are better visualized in a browser with AG Grid.
+
+### 4. VS Code Server (Remote)
+
+**Rejected**: Requires VS Code infrastructure. Goal is to be fully standalone.
+
+## Open Questions
+
+1. **Authentication**: How to handle database passwords securely without VS Code SecretStorage?
+   - Option A: System keychain via `keytar`
+   - Option B: Environment variables only
+   - Option C: Prompt on first use, store encrypted locally
+
+2. **Multiple Instances**: How to handle multiple Claude Code sessions?
+   - Option A: Single shared server (port locking)
+   - Option B: Each session spawns its own server on different port
+
+3. **Query History**: Should we persist query history across sessions?
+   - Option A: In-memory only
+   - Option B: SQLite local database
+   - Option C: Configurable
+
+## Recommendation
+
+Start with **Phase 1 (Extract Core)** as it benefits the existing VS Code extension by improving modularity. Then proceed to Phase 2-3 in parallel (MCP server + UI can be developed concurrently).
+
+Target timeline: Implementation can begin immediately, with core extraction being the lowest-risk first step.
diff --git a/docs/implementations/RFC-003-single-server-architecture.md b/docs/implementations/RFC-003-single-server-architecture.md
new file mode 100644
index 0000000..246cd4b
--- /dev/null
+++ b/docs/implementations/RFC-003-single-server-architecture.md
@@ -0,0 +1,417 @@
+# RFC-003: Single Server Architecture with Session Routing
+
+**Status**: Proposed
+**Created**: 2026-01-28
+**Updated**: 2026-01-28
+
+## Goal
+
+Run a **single SQL Preview server process** that handles requests from multiple windows/clients, with automatic session routing so results appear in the correct context.
+
+## Problem Statement
+
+### Current Behavior
+
+When multiple VS Code/Cursor windows are open, each spawns its own MCP server:
+
+```
+Window 1 → MCP Server on port 3000
+Window 2 → MCP Server on port 3001
+Window 3 → MCP Server on port 3002
+```
+
+This creates several problems:
+
+1. **Port sprawl**: Users see different ports in different contexts, which is confusing
+2. **Resource waste**: Multiple Node.js processes doing the same thing
+3. **Configuration drift**: Each server reads settings independently
+4. **No shared state**: Can't see results from Window 1 while in Window 2's UI
+
+### Desired Behavior
+
+```
+Window 1 ─┐
+Window 2 ─┼──► Single Server (port 8414) ──► Single Web UI
+Window 3 ─┘
+              └── Routes by session ID
+```
+
+One server, one port, one UI - but smart enough to know which window each request came from.
+
+## Why Not Custom Protocol Handlers?
+
+I initially considered using a custom URL scheme (`sql-preview://`) to hide the `localhost:port` complexity. After analysis, this approach has too many drawbacks:
+
+**macOS requires an app bundle**: You can't just register a Node.js script as a protocol handler. You need a signed `.app` bundle with `Info.plist`, which means building and notarizing a real macOS app. This is significant overhead for what should be a simple tool.
+
+**Browser security warnings**: Every time the protocol is triggered, browsers show "This site wants to open an application" dialogs. Users have to click "Allow" repeatedly, which feels janky.
+
+**Security attack surface**: Any website could trigger `sql-preview://malicious-payload`. We'd need to validate and sanitize everything, adding complexity.
+
+**Cross-platform maintenance burden**: macOS uses Info.plist, Windows uses registry keys, Linux uses .desktop files + xdg-mime. Three completely different implementations.
+
+**Jupyter, Vite, webpack, pgAdmin, and every other dev tool just uses localhost:port**. Developers are comfortable with this. Fighting against the grain isn't worth the marginal UX improvement.
+
+**Conclusion**: We'll use `http://localhost:8414` and make it consistent. The port 8414 was chosen because it visually resembles "DATA" - easy to remember and slightly more meaningful than an arbitrary number.
+
+## Architecture
+
+### Overview
+
+```
+┌─────────────────────────────────────────────────────────────┐
+│  User's Machine                                             │
+│                                                             │
+│  ┌─────────┐ ┌─────────┐ ┌─────────┐                       │
+│  │ VS Code │ │ Cursor  │ │ Claude  │                       │
+│  │         │ │         │ │  Code   │                       │
+│  └────┬────┘ └────┬────┘ └────┬────┘                       │
+│       │           │           │                             │
+│       │ session:  │ session:  │ session:                    │
+│       │ "vsc-abc" │ "cur-def" │ "cli-ghi"                   │
+│       │           │           │                             │
+│       └───────────┴───────────┘                             │
+│                   │                                         │
+│                   ▼                                         │
+│       ┌───────────────────────────────────────┐             │
+│       │  sql-preview-server (daemon)          │             │
+│       │                                       │             │
+│       │  Unix Socket: ~/.sql-preview/srv.sock │             │
+│       │  HTTP:        localhost:8414          │             │
+│       │  WebSocket:   localhost:8414/ws       │             │
+│       │                                       │             │
+│       │  ┌─────────────────────────────────┐  │             │
+│       │  │ Session Manager                 │  │             │
+│       │  │ - vsc-abc: VS Code (my-project) │  │             │
+│       │  │ - cur-def: Cursor (analytics)   │  │             │
+│       │  │ - cli-ghi: Claude Code          │  │             │
+│       │  └─────────────────────────────────┘  │             │
+│       └───────────────────────────────────────┘             │
+│                   │                                         │
+│                   ▼                                         │
+│       ┌───────────────────────────────────────┐             │
+│       │  Browser: http://localhost:8414       │             │
+│       │                                       │             │
+│       │  [Session: VS Code - my-project ▼]    │             │
+│       │  ┌─────────────────────────────────┐  │             │
+│       │  │ AG Grid Results                 │  │             │
+│       │  └─────────────────────────────────┘  │             │
+│       └───────────────────────────────────────┘             │
+└─────────────────────────────────────────────────────────────┘
+```
+
+### Why a Daemon?
+
+The server runs as a **user-level daemon** rather than being spawned per-window. This is the right model because:
+
+1. **Shared state**: All windows see the same results store, enabling cross-window workflows
+2. **Single port**: Always 8414, no port hunting or conflicts
+3. **Survives window closes**: Results persist even if you close VS Code
+4. **Lower resource usage**: One Node.js process instead of many
+
+The daemon starts on first use and stays running until explicitly stopped or the user logs out.
+
+### Why Unix Sockets for IPC?
+
+For communication between VS Code/Claude Code and the server, we use Unix sockets (`~/.sql-preview/srv.sock`) instead of HTTP:
+
+1. **No port allocation**: Unix sockets are filesystem paths, not network ports
+2. **Faster**: No TCP overhead, direct kernel-level IPC
+3. **More secure**: Socket file permissions (0600) restrict access to the owning user
+4. **No network exposure**: Impossible to accidentally expose to the network
+
+On Windows, we'll use named pipes (`\\.\pipe\sql-preview`) which provide similar benefits.
+
+HTTP on port 8414 is reserved for the browser-based UI, which genuinely needs HTTP.
+
+### Session Management
+
+Each client registers a session when it connects:
+
+```typescript
+interface Session {
+  id: string; // Unique ID, e.g., "vsc-a1b2c3"
+  displayName: string; // Human-readable, e.g., "VS Code - my-project"
+  clientType: 'vscode' | 'cursor' | 'claude-code' | 'standalone';
+  workspaceRoot?: string; // For context, e.g., "/Users/me/my-project"
+  connectedAt: Date;
+  lastActivityAt: Date;
+}
+```
+
+**Why sessions matter**: When you run a query from VS Code Window 1, the results should appear in a tab associated with that window. Without sessions, all results would be dumped into one shared pool, which would be confusing when working on multiple projects.
+
+**Session ID generation**: We prefix with the client type for easy identification:
+
+- VS Code: `vsc-{uuid}`
+- Cursor: `cur-{uuid}`
+- Claude Code CLI: `cli-{uuid}`
+- Web UI direct: `web-{uuid}`
+
+**Session naming**: The display name is auto-generated from context:
+
+1. Use workspace folder name if available
+2. Fall back to git repo name
+3. Fall back to "Untitled Session"
+
+### MCP Tool Changes
+
+MCP tools now include session context:
+
+```typescript
+// run_query tool
+interface RunQueryParams {
+  sql: string;
+  connection?: string;
+  session: string; // ← Required: identifies the calling window
+  newTab?: boolean;
+}
+
+// Response includes session for routing
+interface RunQueryResult {
+  tabId: string;
+  sessionId: string; // ← Results tagged with session
+  rowCount: number;
+  // ... columns, rows, etc.
+}
+```
+
+The session ID flows through the entire pipeline:
+
+1. Client sends query with session ID
+2. Server executes query
+3. Results stored with session tag
+4. WebSocket pushes to browser with session filter
+5. Browser UI shows results for selected session
+
+### Web UI Session Handling
+
+The browser UI at `http://localhost:8414` shows a session picker:
+
+```
+┌─────────────────────────────────────────────────────────────┐
+│  SQL Preview                                                │
+├─────────────────────────────────────────────────────────────┤
+│  Session: [VS Code - my-project        ▼]                   │
+│           ├─ VS Code - my-project (3 tabs)                  │
+│           ├─ Cursor - analytics (1 tab)                     │
+│           ├─ Claude Code (2 tabs)                           │
+│           └─ All Sessions (6 tabs)                          │
+├─────────────────────────────────────────────────────────────┤
+│  [Query 1] [Query 2] [Query 3]                    [+ New]   │
+├─────────────────────────────────────────────────────────────┤
+│  ┌───────────────────────────────────────────────────────┐  │
+│  │                                                       │  │
+│  │                  AG Grid Results                      │  │
+│  │                                                       │  │
+│  └───────────────────────────────────────────────────────┘  │
+└─────────────────────────────────────────────────────────────┘
+```
+
+**URL routing**:
+
+- `http://localhost:8414` → Shows last active session
+- `http://localhost:8414?session=vsc-abc` → Shows specific session
+- `http://localhost:8414?session=all` → Shows all tabs from all sessions
+
+When a query completes, the MCP response can include a deep link:
+
+```
+Query completed. 142 rows returned.
+View results: http://localhost:8414?session=cli-xyz&tab=abc123
+```
+
+### Server Lifecycle
+
+**Startup sequence**:
+
+```typescript
+async function ensureServerRunning(): Promise<Socket> {
+  const socketPath = path.join(os.homedir(), '.sql-preview', 'srv.sock');
+  const pidPath = path.join(os.homedir(), '.sql-preview', 'server.pid');
+
+  // 1. Check if server is already running
+  if (await isSocketResponsive(socketPath)) {
+    return connect(socketPath);
+  }
+
+  // 2. Clean up stale socket/pid if server crashed
+  await cleanupStaleFiles(socketPath, pidPath);
+
+  // 3. Spawn server as detached background process
+  const serverBin = await resolveServerBinary();
+  const child = spawn(serverBin, ['--daemon'], {
+    detached: true,
+    stdio: 'ignore',
+    env: { ...process.env, SQL_PREVIEW_DAEMON: '1' },
+  });
+  child.unref();
+
+  // 4. Wait for server to be ready (polls socket)
+  await waitForSocket(socketPath, { timeout: 5000 });
+
+  return connect(socketPath);
+}
+```
+
+**Why check socket responsiveness, not just existence?**: A socket file might exist from a crashed server. We send a ping message and wait for a pong to confirm the server is actually alive.
+
+**Shutdown**: The server shuts down after 30 minutes of inactivity (no connected clients, no recent queries). This prevents orphan processes while keeping the server warm for typical usage patterns.
+
+**Manual control**:
+
+```bash
+sql-preview-server start    # Start daemon (if not running)
+sql-preview-server stop     # Stop daemon gracefully
+sql-preview-server status   # Show running status, port, sessions
+sql-preview-server logs     # Tail server logs
+```
+
+### File Locations
+
+```
+~/.sql-preview/
+├── srv.sock              # Unix socket for IPC
+├── server.pid            # PID file for daemon management
+├── server.log            # Server logs (rotated, max 10MB)
+├── config.json           # User configuration (connections, settings)
+└── sessions/             # Persisted session data (optional)
+    ├── vsc-abc.json
+    └── cli-xyz.json
+```
+
+**Why `~/.sql-preview/` instead of XDG directories?**: Simplicity. XDG compliance means different paths for config vs. runtime vs. cache, across different OSes. A single dotfolder is easier to understand, backup, and delete.
+
+## Configuration
+
+Without VS Code settings, we need a standalone configuration approach:
+
+```json
+// ~/.sql-preview/config.json
+{
+  "connections": {
+    "default": {
+      "type": "trino",
+      "host": "trino.company.com",
+      "port": 443,
+      "user": "analyst",
+      "catalog": "hive",
+      "schema": "default",
+      "ssl": true
+    },
+    "local-postgres": {
+      "type": "postgres",
+      "host": "localhost",
+      "port": 5432,
+      "user": "postgres",
+      "database": "myapp"
+    },
+    "analytics-db": {
+      "type": "sqlite",
+      "path": "/path/to/analytics.db"
+    }
+  },
+  "defaultConnection": "default",
+  "server": {
+    "port": 8414,
+    "idleTimeoutMinutes": 30
+  },
+  "ui": {
+    "maxRows": 10000,
+    "theme": "system"
+  },
+  "safeMode": true
+}
+```
+
+**Environment variable overrides** (useful for CI/containers):
+
+```bash
+SQL_PREVIEW_HOST=trino.company.com
+SQL_PREVIEW_USER=analyst
+SQL_PREVIEW_PASSWORD=secret        # Never stored in config file
+SQL_PREVIEW_PORT=8414
+```
+
+**Password handling**: Passwords are never stored in `config.json`. Options:
+
+1. Environment variable (`SQL_PREVIEW_PASSWORD`)
+2. System keychain via `keytar` library (prompts once, stores securely)
+3. Prompt on first query (stores in memory only)
+
+We'll use approach #2 (keychain) as default, with #1 as override for automation scenarios.
+
+## Security Considerations
+
+**Unix socket permissions**: The socket file is created with mode `0600` (owner read/write only). Other users on the system cannot connect.
+
+**No network binding**: The HTTP server binds to `127.0.0.1:8414`, never `0.0.0.0`. The server is only accessible from the local machine.
+
+**Session isolation**: Database credentials are stored per-connection, not per-session. All sessions with access to the server can use any configured connection. This is intentional - the server is single-user.
+
+**Safe mode**: By default, only SELECT/SHOW/DESCRIBE/EXPLAIN/WITH queries are allowed through MCP. This prevents accidental data modification when an AI agent is running queries. Can be disabled in config for trusted scenarios.
+
+## Implementation Plan
+
+### Phase 1: Daemon Infrastructure
+
+1. Create daemon process management (start, stop, health check)
+2. Implement Unix socket server alongside existing HTTP server
+3. Add PID file and lock management
+4. Handle graceful shutdown on SIGTERM/SIGINT
+5. Add idle timeout auto-shutdown
+
+### Phase 2: Session Management
+
+1. Define session registration protocol over Unix socket
+2. Implement in-memory session store
+3. Modify QueryExecutor to tag results with session ID
+4. Add session filtering to TabManager
+5. Update MCP tools to require session parameter
+
+### Phase 3: Client Updates
+
+1. Update VS Code extension to connect to daemon instead of spawning server
+2. Add session registration on extension activation
+3. Update MCP server wrapper to relay through daemon
+4. Handle daemon not running (auto-start)
+
+### Phase 4: Web UI Updates
+
+1. Add session picker component
+2. Implement session-filtered tab list
+3. Add URL parameter support for session deep links
+4. Add "All Sessions" view option
+5. Show session indicator in status bar
+
+### Phase 5: Standalone Package
+
+1. Extract daemon into `@sql-preview/server` npm package
+2. Create CLI with start/stop/status commands
+3. Add configuration file support
+4. Write setup documentation for Claude Code users
+
+## Migration Path
+
+**For existing VS Code extension users**: The extension will detect if the new daemon is available. If so, it connects to the daemon. If not, it falls back to the current per-window server behavior. This allows gradual rollout.
+
+**For new standalone users**:
+
+```bash
+npm install -g @sql-preview/server
+sql-preview-server start
+claude mcp add sql-preview -- sql-preview-client
+```
+
+The `sql-preview-client` command connects to the running daemon and bridges stdio MCP to the Unix socket.
+
+## Open Questions
+
+1. **Session persistence**: Should session data (tabs, results) persist across server restarts?
+   - Leaning toward: Yes, with configurable TTL (default 24 hours)
+
+2. **Multi-user machines**: Should we support system-wide server for shared machines?
+   - Leaning toward: No, keep it simple with per-user daemon
+
+3. **Remote server mode**: Should the daemon be exposable over network for team sharing?
+   - Leaning toward: Out of scope for this RFC, but architecture shouldn't preclude it
diff --git a/docs/implementations/RFC-004-mcp-apps-ui.md b/docs/implementations/RFC-004-mcp-apps-ui.md
new file mode 100644
index 0000000..4e5d4f3
--- /dev/null
+++ b/docs/implementations/RFC-004-mcp-apps-ui.md
@@ -0,0 +1,737 @@
+# RFC-004: MCP Apps Integration for Inline Query Results
+
+**Status**: Proposed
+**Created**: 2026-01-28
+
+## Goal
+
+Implement MCP Apps support so SQL query results render as an **interactive AG Grid directly inside the conversation** in Claude Desktop, Claude Web, and other MCP Apps-compatible hosts.
+
+## Why This Matters
+
+Currently, when Claude Code or Claude Desktop calls our `run_query` tool, users see:
+
+```
+Query returned 142 rows.
+| id | customer | revenue    |
+|----|----------|------------|
+| 1  | Acme     | $2,450,000 |
+| 2  | Globex   | $1,890,000 |
+... (plain text, no interaction)
+
+View interactive results at http://localhost:8414
+```
+
+Users must leave the conversation, open a browser, and lose context. With MCP Apps:
+
+```
+Query returned 142 rows.
+┌─────────────────────────────────────────────────────────────┐
+│  [Interactive AG Grid embedded in conversation]             │
+│  - Click headers to sort                                    │
+│  - Filter, resize columns                                   │
+│  - Copy cells, export CSV                                   │
+│  - All without leaving the chat                             │
+└─────────────────────────────────────────────────────────────┘
+```
+
+The results live where the conversation happens. Users can ask follow-up questions while looking at the data. This is the experience we want.
+
+## How MCP Apps Work
+
+MCP Apps is an extension to the MCP protocol that allows tools to return interactive HTML UIs that render in sandboxed iframes within the host application.
+
+### The Protocol Flow
+
+```
+┌──────────────┐         ┌──────────────┐         ┌──────────────┐
+│    Claude    │         │  SQL Preview │         │   UI Bundle  │
+│    (Host)    │         │  MCP Server  │         │   (HTML/JS)  │
+└──────┬───────┘         └──────┬───────┘         └──────┬───────┘
+       │                        │                        │
+       │  1. Initialize         │                        │
+       │───────────────────────>│                        │
+       │                        │                        │
+       │  2. List tools         │                        │
+       │───────────────────────>│                        │
+       │                        │                        │
+       │  3. Return tools with  │                        │
+       │     _meta.ui.resourceUri                        │
+       │<───────────────────────│                        │
+       │                        │                        │
+       │  4. User: "show top customers"                  │
+       │  5. LLM decides to call run_query               │
+       │                        │                        │
+       │  6. Call run_query     │                        │
+       │───────────────────────>│                        │
+       │                        │                        │
+       │  7. Execute SQL        │                        │
+       │                        │                        │
+       │  8. Return result +    │                        │
+       │     columns/rows data  │                        │
+       │<───────────────────────│                        │
+       │                        │                        │
+       │  9. Fetch UI resource  │                        │
+       │───────────────────────>│                        │
+       │                        │                        │
+       │  10. Return bundled HTML                        │
+       │<───────────────────────│                        │
+       │                        │                        │
+       │  11. Render iframe     │                        │
+       │─────────────────────────────────────────────────>
+       │                        │                        │
+       │  12. Push tool result to iframe via postMessage │
+       │─────────────────────────────────────────────────>
+       │                        │                        │
+       │  13. UI renders AG Grid with data               │
+       │                        │                        │
+       │  14. User clicks "Re-run Query" in UI           │
+       │<─────────────────────────────────────────────────
+       │                        │                        │
+       │  15. Proxy tool call   │                        │
+       │───────────────────────>│                        │
+       │                        │                        │
+       │  16. Fresh results     │                        │
+       │<───────────────────────│                        │
+       │                        │                        │
+       │  17. Push to UI        │                        │
+       │─────────────────────────────────────────────────>
+```
+
+### Key Concepts
+
+**Tool with UI metadata**: The tool declares a `_meta.ui.resourceUri` field:
+
+```typescript
+{
+  name: "run_query",
+  description: "Execute SQL query and display results",
+  inputSchema: {
+    type: "object",
+    properties: {
+      sql: { type: "string", description: "SQL query to execute" },
+      connection: { type: "string", description: "Connection profile name" }
+    },
+    required: ["sql"]
+  },
+  _meta: {
+    ui: {
+      resourceUri: "ui://sql-preview/results-grid"
+    }
+  }
+}
+```
+
+**UI Resource**: The server serves a bundled HTML/JS file when the host requests `ui://sql-preview/results-grid`:
+
+```typescript
+// When host requests the UI resource
+{
+  contents: [
+    {
+      uri: 'ui://sql-preview/results-grid',
+      mimeType: 'text/html;profile=mcp-app',
+      text: '<html>...bundled AG Grid app...</html>',
+    },
+  ];
+}
+```
+
+**App class**: The UI uses `@modelcontextprotocol/ext-apps` to communicate with the host:
+
+```typescript
+import { App } from '@modelcontextprotocol/ext-apps';
+
+const app = new App({ name: 'SQL Preview', version: '1.0.0' });
+app.connect();
+
+// Receive query results when tool is called
+app.ontoolresult = result => {
+  const { columns, rows, query, executionTime } = result.data;
+  renderGrid(columns, rows);
+};
+
+// User clicks "Re-run" button
+async function rerunQuery(sql: string) {
+  const result = await app.callServerTool({
+    name: 'run_query',
+    arguments: { sql },
+  });
+  renderGrid(result.data.columns, result.data.rows);
+}
+```
+
+### Security Model
+
+MCP Apps run in sandboxed iframes with restricted permissions:
+
+- Cannot access parent window's DOM or cookies
+- All communication via postMessage (abstracted by App class)
+- Host controls which capabilities the app can access
+- CSP can restrict which external domains the app loads resources from
+
+For SQL Preview, we don't need any special permissions - we're just displaying data.
+
+## Architecture
+
+### Project Structure
+
+```
+sql-preview/
+├── src/
+│   ├── extension.ts                    # VS Code extension (existing)
+│   ├── modules/
+│   │   └── mcp/
+│   │       ├── McpServer.ts            # Existing SSE server
+│   │       ├── McpToolManager.ts       # Existing tool definitions
+│   │       └── McpAppsServer.ts        # NEW: Streamable HTTP server with UI resources
+│   │
+│   └── mcp-app/                        # NEW: MCP App UI
+│       ├── index.html                  # Entry point
+│       ├── App.tsx                     # Main React component
+│       ├── components/
+│       │   ├── ResultsGrid.tsx         # AG Grid wrapper
+│       │   ├── Toolbar.tsx             # Export, copy, re-run buttons
+│       │   ├── QueryInfo.tsx           # Shows query text, timing
+│       │   └── StatusBar.tsx           # Row count, connection info
+│       ├── hooks/
+│       │   └── useMcpApp.ts            # App class wrapper
+│       └── styles/
+│           └── theme.css               # Matches host theme
+│
+├── vite.config.mcp-app.ts              # NEW: Builds single-file HTML bundle
+└── package.json
+```
+
+### Server Implementation
+
+We'll create a new `McpAppsServer` that uses Streamable HTTP transport (the modern approach) and registers UI resources:
+
+```typescript
+// src/modules/mcp/McpAppsServer.ts
+import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
+import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
+import {
+  registerAppTool,
+  registerAppResource,
+  RESOURCE_MIME_TYPE,
+} from '@modelcontextprotocol/ext-apps/server';
+import express from 'express';
+import fs from 'node:fs/promises';
+import path from 'node:path';
+
+export class McpAppsServer {
+  private server: McpServer;
+  private app: express.Express;
+
+  constructor(private queryExecutor: QueryExecutor) {
+    this.server = new McpServer({
+      name: 'sql-preview',
+      version: '1.0.0',
+    });
+
+    this.setupTools();
+    this.setupResources();
+    this.app = express();
+  }
+
+  private setupTools() {
+    const resourceUri = 'ui://sql-preview/results-grid';
+
+    // Register run_query with UI metadata
+    registerAppTool(
+      this.server,
+      'run_query',
+      {
+        title: 'Run SQL Query',
+        description: 'Execute a SQL query and display results in an interactive grid',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            sql: { type: 'string', description: 'SQL query to execute' },
+            connection: { type: 'string', description: 'Connection profile name (optional)' },
+          },
+          required: ['sql'],
+        },
+        _meta: { ui: { resourceUri } },
+      },
+      async params => {
+        const { sql, connection } = params;
+
+        // Execute query using existing infrastructure
+        const result = await this.queryExecutor.execute(sql, connection);
+
+        return {
+          content: [
+            {
+              type: 'text',
+              text: `Query returned ${result.rowCount} rows in ${result.executionTime}ms`,
+            },
+          ],
+          // Data passed to the UI
+          data: {
+            query: sql,
+            columns: result.columns,
+            rows: result.rows,
+            rowCount: result.rowCount,
+            executionTime: result.executionTime,
+            connection: connection || 'default',
+          },
+        };
+      }
+    );
+
+    // List available connections (no UI needed)
+    this.server.tool(
+      'list_connections',
+      'List available database connection profiles',
+      {},
+      async () => {
+        const connections = await this.getConnections();
+        return {
+          content: [{ type: 'text', text: JSON.stringify(connections, null, 2) }],
+        };
+      }
+    );
+  }
+
+  private setupResources() {
+    const resourceUri = 'ui://sql-preview/results-grid';
+
+    registerAppResource(
+      this.server,
+      resourceUri,
+      resourceUri,
+      {
+        mimeType: RESOURCE_MIME_TYPE,
+        _meta: {
+          ui: {
+            // CSP: We need AG Grid from CDN if not bundled
+            // If fully bundled, this can be empty
+            csp: {
+              connectDomains: [], // No external API calls needed
+              resourceDomains: [], // Everything bundled
+            },
+          },
+        },
+      },
+      async () => {
+        // Read the bundled HTML file
+        const html = await fs.readFile(path.join(__dirname, '../../dist/mcp-app.html'), 'utf-8');
+        return {
+          contents: [{ uri: resourceUri, mimeType: RESOURCE_MIME_TYPE, text: html }],
+        };
+      }
+    );
+  }
+
+  async start(port: number = 8414) {
+    this.app.use(express.json());
+
+    // MCP endpoint
+    this.app.post('/mcp', async (req, res) => {
+      const transport = new StreamableHTTPServerTransport({
+        sessionIdGenerator: undefined,
+        enableJsonResponse: true,
+      });
+      res.on('close', () => transport.close());
+      await this.server.connect(transport);
+      await transport.handleRequest(req, res, req.body);
+    });
+
+    this.app.listen(port, '127.0.0.1', () => {
+      console.log(`MCP Apps Server listening on http://127.0.0.1:${port}/mcp`);
+    });
+  }
+}
+```
+
+### UI Implementation
+
+The UI is a React app that uses AG Grid and communicates via the `App` class:
+
+```typescript
+// src/mcp-app/App.tsx
+import { useEffect, useState, useCallback } from 'react';
+import { App as McpApp } from '@modelcontextprotocol/ext-apps';
+import { AgGridReact } from 'ag-grid-react';
+import 'ag-grid-community/styles/ag-grid.css';
+import 'ag-grid-community/styles/ag-theme-alpine.css';
+
+interface QueryResult {
+  query: string;
+  columns: Array<{ name: string; type: string }>;
+  rows: Array<Record<string, unknown>>;
+  rowCount: number;
+  executionTime: number;
+  connection: string;
+}
+
+export function App() {
+  const [mcpApp] = useState(() => new McpApp({
+    name: 'SQL Preview',
+    version: '1.0.0'
+  }));
+  const [result, setResult] = useState<QueryResult | null>(null);
+  const [loading, setLoading] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  const [theme, setTheme] = useState<'light' | 'dark'>('light');
+
+  useEffect(() => {
+    // Connect to host
+    mcpApp.connect();
+
+    // Receive initial tool result
+    mcpApp.ontoolresult = (toolResult) => {
+      if (toolResult.data) {
+        setResult(toolResult.data as QueryResult);
+        setError(null);
+      }
+    };
+
+    // Handle theme changes from host
+    mcpApp.onhostcontextchanged = (context) => {
+      if (context.theme) {
+        setTheme(context.theme === 'dark' ? 'dark' : 'light');
+      }
+    };
+
+    // Get initial theme
+    const hostContext = mcpApp.getHostContext();
+    if (hostContext?.theme) {
+      setTheme(hostContext.theme === 'dark' ? 'dark' : 'light');
+    }
+
+    return () => mcpApp.close();
+  }, [mcpApp]);
+
+  const rerunQuery = useCallback(async () => {
+    if (!result?.query) return;
+
+    setLoading(true);
+    setError(null);
+
+    try {
+      const newResult = await mcpApp.callServerTool({
+        name: 'run_query',
+        arguments: {
+          sql: result.query,
+          connection: result.connection,
+        },
+      });
+
+      if (newResult.data) {
+        setResult(newResult.data as QueryResult);
+      }
+    } catch (err) {
+      setError(err instanceof Error ? err.message : 'Query failed');
+    } finally {
+      setLoading(false);
+    }
+  }, [mcpApp, result]);
+
+  const exportCsv = useCallback(() => {
+    if (!result) return;
+
+    const headers = result.columns.map(c => c.name).join(',');
+    const rows = result.rows.map(row =>
+      result.columns.map(c => JSON.stringify(row[c.name] ?? '')).join(',')
+    ).join('\n');
+
+    const csv = `${headers}\n${rows}`;
+    const blob = new Blob([csv], { type: 'text/csv' });
+    const url = URL.createObjectURL(blob);
+
+    // Request host to open download
+    mcpApp.openLink({ url });
+  }, [mcpApp, result]);
+
+  const columnDefs = result?.columns.map(col => ({
+    field: col.name,
+    headerName: col.name,
+    sortable: true,
+    filter: true,
+    resizable: true,
+  })) ?? [];
+
+  return (
+    <div className={`app ${theme === 'dark' ? 'ag-theme-alpine-dark' : 'ag-theme-alpine'}`}>
+      {/* Toolbar */}
+      <div className="toolbar">
+        <span className="query-info">
+          {result ? `${result.rowCount} rows · ${result.executionTime}ms` : 'No results'}
+        </span>
+        <div className="toolbar-actions">
+          <button onClick={rerunQuery} disabled={loading || !result}>
+            {loading ? 'Running...' : 'Re-run'}
+          </button>
+          <button onClick={exportCsv} disabled={!result}>
+            Export CSV
+          </button>
+        </div>
+      </div>
+
+      {/* Error display */}
+      {error && <div className="error">{error}</div>}
+
+      {/* Grid */}
+      {result && (
+        <div className="grid-container">
+          <AgGridReact
+            columnDefs={columnDefs}
+            rowData={result.rows}
+            defaultColDef={{
+              sortable: true,
+              filter: true,
+              resizable: true,
+            }}
+            enableCellTextSelection={true}
+            ensureDomOrder={true}
+          />
+        </div>
+      )}
+
+      {/* Query preview */}
+      {result && (
+        <div className="query-preview">
+          <code>{result.query}</code>
+        </div>
+      )}
+    </div>
+  );
+}
+```
+
+### Build Configuration
+
+Use Vite with `vite-plugin-singlefile` to bundle everything into one HTML file:
+
+```typescript
+// vite.config.mcp-app.ts
+import { defineConfig } from 'vite';
+import react from '@vitejs/plugin-react';
+import { viteSingleFile } from 'vite-plugin-singlefile';
+
+export default defineConfig({
+  plugins: [react(), viteSingleFile()],
+  root: 'src/mcp-app',
+  build: {
+    outDir: '../../dist',
+    emptyOutDir: false,
+    rollupOptions: {
+      input: 'src/mcp-app/index.html',
+      output: {
+        entryFileNames: 'mcp-app.js',
+      },
+    },
+  },
+});
+```
+
+The bundle will include:
+
+- React (~40KB gzipped)
+- AG Grid Community (~90KB gzipped)
+- Our components (~5KB)
+- Total: ~135KB (acceptable for inline rendering)
+
+## Tool Definitions
+
+### run_query (with UI)
+
+The primary tool that executes queries and displays results in the inline grid.
+
+```typescript
+{
+  name: "run_query",
+  title: "Run SQL Query",
+  description: "Execute a SQL query against the configured database and display results in an interactive grid. Supports sorting, filtering, and export.",
+  inputSchema: {
+    type: "object",
+    properties: {
+      sql: {
+        type: "string",
+        description: "The SQL query to execute"
+      },
+      connection: {
+        type: "string",
+        description: "Connection profile name. Uses default if not specified."
+      }
+    },
+    required: ["sql"]
+  },
+  _meta: {
+    ui: {
+      resourceUri: "ui://sql-preview/results-grid"
+    }
+  }
+}
+```
+
+### list_connections (no UI)
+
+Simple text response, no interactive UI needed.
+
+```typescript
+{
+  name: "list_connections",
+  description: "List available database connection profiles",
+  inputSchema: { type: "object", properties: {} }
+}
+```
+
+### describe_table (with UI)
+
+Could show schema information in a structured grid.
+
+```typescript
+{
+  name: "describe_table",
+  title: "Describe Table",
+  description: "Show table schema including columns, types, and constraints",
+  inputSchema: {
+    type: "object",
+    properties: {
+      table: { type: "string", description: "Table name (schema.table format supported)" }
+    },
+    required: ["table"]
+  },
+  _meta: {
+    ui: {
+      resourceUri: "ui://sql-preview/schema-viewer"
+    }
+  }
+}
+```
+
+## UI Features
+
+The inline grid should support:
+
+| Feature           | Implementation                                    |
+| ----------------- | ------------------------------------------------- |
+| **Sorting**       | AG Grid built-in, click column headers            |
+| **Filtering**     | AG Grid built-in, filter icon in headers          |
+| **Column resize** | AG Grid built-in, drag column borders             |
+| **Copy cells**    | AG Grid cell selection + Ctrl+C                   |
+| **Export CSV**    | Custom button → blob download                     |
+| **Re-run query**  | Custom button → `app.callServerTool()`            |
+| **Theme sync**    | `app.onhostcontextchanged` → switch AG Grid theme |
+| **Show query**    | Collapsible panel showing the executed SQL        |
+
+## Deployment Options
+
+### Option 1: Standalone Server (Claude Desktop / Claude Web)
+
+For users connecting Claude to SQL Preview as a remote MCP server:
+
+```bash
+# Install globally
+npm install -g @sql-preview/server
+
+# Start server
+sql-preview-server --port 8414
+
+# Add to Claude as custom connector
+# URL: https://<your-tunnel>/mcp  (via cloudflared or similar)
+```
+
+### Option 2: VS Code Extension (existing + enhanced)
+
+The VS Code extension can start the MCP Apps server alongside the existing SSE server:
+
+```typescript
+// In extension activation
+const mcpAppsServer = new McpAppsServer(queryExecutor);
+await mcpAppsServer.start(8414);
+
+// Now both work:
+// - SSE at :8414/sse (existing, for Cursor/Claude Code stdio relay)
+// - Streamable HTTP at :8414/mcp (for Claude Desktop with UI)
+```
+
+### Option 3: Claude Code with stdio
+
+For Claude Code CLI users, we need a stdio wrapper that exposes the same tools:
+
+```bash
+# Claude Code adds via stdio
+claude mcp add sql-preview -- sql-preview-server --stdio
+```
+
+When running in stdio mode, the server won't have HTTP for the UI resource delivery. Claude Code terminal can't render iframes anyway, so users fall back to:
+
+1. Text-only results in the terminal
+2. Open browser at `localhost:8414` for interactive view
+
+## Client Support Matrix
+
+| Client            | MCP Apps Support | Fallback              |
+| ----------------- | ---------------- | --------------------- |
+| Claude Web        | Yes              | -                     |
+| Claude Desktop    | Yes              | -                     |
+| VS Code Insiders  | Yes              | -                     |
+| Goose             | Yes              | -                     |
+| Postman           | Yes              | -                     |
+| Claude Code (CLI) | No (terminal)    | Text + browser link   |
+| Cursor            | Unknown          | Likely text + browser |
+
+For unsupported clients, the tool still works - they just get text output instead of the interactive grid. The existing browser UI at `localhost:8414` serves as the fallback.
+
+## Implementation Plan
+
+### Phase 1: Basic MCP App
+
+1. Set up Vite build for single-file HTML bundle
+2. Create minimal React app with AG Grid
+3. Implement `App` class connection and `ontoolresult` handler
+4. Create `McpAppsServer` with Streamable HTTP transport
+5. Register `run_query` tool with UI metadata
+6. Register UI resource handler
+7. Test with `basic-host` from ext-apps repo
+
+### Phase 2: Full Feature Parity
+
+1. Port all AG Grid features from VS Code webview:
+   - Column resizing and persistence
+   - Sorting and filtering
+   - Cell selection and copy
+   - Row height adjustment
+2. Implement export CSV functionality
+3. Implement re-run query via `callServerTool`
+4. Add theme synchronization with host
+
+### Phase 3: Integration
+
+1. Add MCP Apps server to VS Code extension startup
+2. Support both SSE (legacy) and Streamable HTTP endpoints
+3. Create stdio wrapper for Claude Code users
+4. Update configuration to support both modes
+
+### Phase 4: Polish
+
+1. Add `describe_table` tool with schema viewer UI
+2. Add query history UI (if host supports state)
+3. Handle large result sets (pagination)
+4. Error state UI improvements
+5. Loading states and animations
+
+## Open Questions
+
+1. **Bundle size**: AG Grid is ~90KB gzipped. Is this acceptable for inline rendering? Could use a lighter grid if needed.
+
+2. **Multiple queries**: When user runs multiple queries, does each get its own iframe? Or should we implement tabs within one iframe?
+
+3. **State persistence**: Can the UI persist across conversation turns? Or does it reset each time?
+
+4. **Fullscreen mode**: Should we support `app.requestDisplayMode('fullscreen')` for complex data exploration?
+
+5. **Streaming results**: For large queries, can we stream rows to the UI progressively using `ontoolinputpartial`?
+
+## References
+
+- [MCP Apps Documentation](https://modelcontextprotocol.io/docs/extensions/apps.md)
+- [MCP Apps Specification](https://github.com/modelcontextprotocol/ext-apps/blob/main/specification/draft/apps.mdx)
+- [ext-apps GitHub Repository](https://github.com/modelcontextprotocol/ext-apps)
+- [App Class API](https://modelcontextprotocol.github.io/ext-apps/api/classes/app.App.html)
+- [Example: Cohort Heatmap Server](https://github.com/modelcontextprotocol/ext-apps/tree/main/examples/cohort-heatmap-server)
diff --git a/src/core/execution/QueryExecutor.ts b/src/core/execution/QueryExecutor.ts
index e179056..6cfd0be 100644
--- a/src/core/execution/QueryExecutor.ts
+++ b/src/core/execution/QueryExecutor.ts
@@ -1,28 +1,22 @@
 import * as vscode from 'vscode';
-import { IConnector, ConnectorConfig } from '../../connectors/base/IConnector';
 import { ConnectorRegistry } from '../../connectors/base/ConnectorRegistry';
 import { QueryPage } from '../../common/types';
-import { ConnectionManager } from '../../services/ConnectionManager'; // Referencing old service for now
+import { ConnectionManager } from '../../services/ConnectionManager';
+import { DaemonClient } from '../../services/DaemonClient';
 import { Logger } from '../logging/Logger';
+import { ConnectorConfig } from '../../connectors/base/IConnector';
 
 export class QueryExecutor {
   private logger = Logger.getInstance();
 
   constructor(
     private readonly connectorRegistry: ConnectorRegistry,
-    private readonly connectionManager: ConnectionManager
+    private readonly connectionManager: ConnectionManager,
+    private readonly daemonClient: DaemonClient
   ) {}
 
-  private getConnector(type: string): IConnector {
-    const connector = this.connectorRegistry.get(type);
-    if (!connector) {
-      throw new Error(`Connector '${type}' not registered`);
-    }
-    return connector;
-  }
-
   /**
-   * Orchestrates the query execution.
+   * Orchestrates the query execution via Daemon.
    */
   async *execute(
     query: string,
@@ -30,64 +24,81 @@ export class QueryExecutor {
     abortSignal?: AbortSignal
   ): AsyncGenerator<QueryPage, void, unknown> {
     const correlationId = Math.random().toString(36).substring(7);
-    this.logger.info(`Starting query execution`, { query }, correlationId);
+    this.logger.info(`Starting query execution via Daemon`, { query }, correlationId);
 
-    // Resolve Connection Profile
+    // Resolve Connection Profile (Client Side) to pass to Daemon
     const connections = await this.connectionManager.getConnections();
-    if (connections.length === 0) {
-      throw new Error(
-        "No connection profile found. Please add a connection in SQL Preview 'Connections' menu."
-      );
+    let profile: any = undefined;
+
+    if (connections.length > 0) {
+      // Fallback or Active logic
+      const config = vscode.workspace.getConfiguration('sqlPreview', contextUri);
+      const defaultType = config.get<string>('defaultConnector', 'trino');
+      const matching = connections.find(c => c.type === defaultType);
+      const active = matching || connections[0];
+
+      if (active) {
+        profile = await this.connectionManager.getConnection(active.id);
+      }
     }
 
-    // active connection or defaulting to the type specified in settings
-    const config = vscode.workspace.getConfiguration('sqlPreview', contextUri);
-    const defaultType = config.get<string>('defaultConnector', 'trino');
+    try {
+      // 1. Submit Query with Profile Override
+      const remoteTabId = await this.daemonClient.runQuery(query, true, profile);
 
-    // 1. Try to find a connection matching the configured default type
-    const matchingConnection = connections.find(c => c.type === defaultType);
+      // 2. Poll for Results
+      let isDone = false;
+      let currentOffset = 0;
 
-    // 2. Fallback to the first available connection if no match found
-    const activeConnection = matchingConnection || connections[0];
+      while (!isDone) {
+        if (abortSignal?.aborted) {
+          this.logger.info(`Abort signal detected for local query loop`);
+          try {
+            await this.daemonClient.cancelQuery(remoteTabId);
+            this.logger.info(`Daemon cancel invoked for ${remoteTabId}`);
+          } catch (e) {
+            this.logger.error('Failed to cancel query', e);
+          }
+          return;
+        }
 
-    if (!activeConnection) {
-      throw new Error('No connection profile found.');
-    }
-    const profile = await this.connectionManager.getConnection(activeConnection.id);
-    if (!profile) {
-      throw new Error('Failed to load connection profile.');
-    }
+        const info = await this.daemonClient.getTabInfo(remoteTabId, currentOffset);
+        // info structure: { id, title, status, columns, rows, error, ... }
 
-    // Generic Config Construction: Spread profile properties
-    // This allows any connector-specific fields (catalog, dbName, etc.) to pass through
-    const connectorConfig: ConnectorConfig = {
-      ...profile,
-      maxRows: config.get<number>('maxRowsToDisplay', 500),
-      // Default sslVerify to true if undefined, but respect profile setting
-      sslVerify:
-        'sslVerify' in profile && profile.sslVerify !== undefined ? profile.sslVerify : true,
-    };
-
-    // Validation (Connector Self-Validation)
-    const connector = this.getConnector(profile.type);
-    const validationError = connector.validateConfig(connectorConfig);
-    if (validationError) {
-      this.logger.error(
-        `Configuration validation failed`,
-        { error: validationError },
-        correlationId
-      );
-      throw new Error(`Configuration Error: ${validationError}`);
-    }
+        if (info.status === 'error') {
+          throw new Error(info.error || 'Unknown daemon error');
+        }
 
-    let authHeader: string | undefined;
-    if ('password' in profile && profile.password && 'user' in profile) {
-      authHeader = 'Basic ' + Buffer.from(`${profile.user}:${profile.password}`).toString('base64');
-    }
+        const newRows = info.rows || [];
+        if (newRows.length > 0) {
+          currentOffset += newRows.length;
+          yield {
+            columns: info.columns,
+            data: newRows,
+            stats: {
+              state: info.status === 'success' ? 'FINISHED' : 'RUNNING',
+              rowCount: info.rowCount,
+            },
+          };
+        } else if (info.columns && currentOffset === 0) {
+          // Yield columns even if no rows yet
+          yield {
+            columns: info.columns,
+            data: [],
+            stats: {
+              state: 'RUNNING',
+              rowCount: 0,
+            },
+          };
+        }
 
-    try {
-      yield* connector.runQuery(query, connectorConfig, authHeader, abortSignal);
-      this.logger.info(`Query execution completed`, undefined, correlationId);
+        if (info.status === 'success') {
+          isDone = true;
+        } else {
+          // Still loading, wait a bit
+          await new Promise(r => setTimeout(r, 200));
+        }
+      }
     } catch (e: unknown) {
       this.logger.error(`Query execution failed`, e, correlationId);
       throw e;
@@ -95,26 +106,33 @@ export class QueryExecutor {
   }
 
   /**
-   * Tests connectivity by running a lightweight query (SELECT 1).
+   * Tests connectivity
+   * TODO: Implement via Daemon
    */
   public async testConnection(
     type: string,
     config: ConnectorConfig,
     authHeader?: string
   ): Promise<{ success: boolean; error?: string }> {
+    // Fallback to local check if possible, or fail
+    // For now, let's just return true/false dummy or try local if we have connectors loaded locally?
+    // ServiceContainer still loads connectors locally.
+    // So we can fallback to local test for now!
     try {
-      const connector = this.getConnector(type);
-      // Validate before running
+      const connector = this.connectorRegistry.get(type);
+      if (!connector) {
+        throw new Error('Connector not found locally');
+      }
+
       const valError = connector.validateConfig(config);
       if (valError) {
         return { success: false, error: valError };
       }
 
       const iterator = connector.runQuery('SELECT 1', config, authHeader);
-      // Attempt to fetch first page to validate connection & auth
       await iterator.next();
       return { success: true };
-    } catch (e: unknown) {
+    } catch (e) {
       const message = e instanceof Error ? e.message : String(e);
       return { success: false, error: message };
     }
diff --git a/src/extension.ts b/src/extension.ts
index 9293d0d..2138d78 100644
--- a/src/extension.ts
+++ b/src/extension.ts
@@ -1,39 +1,37 @@
 import * as vscode from 'vscode';
 import { ResultsViewProvider } from './resultsViewProvider';
-import { SqlPreviewMcpServer } from './modules/mcp/McpServer';
 import { PrestoCodeLensProvider } from './PrestoCodeLensProvider';
 import { getQueryAtOffset } from './utils/querySplitter';
 import { ServiceContainer } from './services/ServiceContainer';
 import { QueryResults } from './common/types';
 import { BaseError } from './common/errors';
+import { Logger } from './core/logging/Logger';
 
 // Global instance to allow access in tests/commands if strictly necessary,
-// but preferred to access via ServiceContainer unless legacy.
+// but preferred to access via ServiceContainer.
 let serviceContainer: ServiceContainer;
-let mcpServer: SqlPreviewMcpServer | undefined;
+
 // Status Bar Item
-let mcpStatusBarItem: vscode.StatusBarItem;
+let daemonStatusBarItem: vscode.StatusBarItem;
 
 // Create output channel for logging
-const outputChannel = vscode.window.createOutputChannel('SQL Preview');
-
 export function activate(context: vscode.ExtensionContext) {
   // Validate extension context
   if (!context || !context.extensionUri) {
-    outputChannel.appendLine('ERROR: Invalid extension context or URI during activation');
+    Logger.getInstance().error('Invalid extension context or URI during activation');
     vscode.window.showErrorMessage('SQL Preview: Extension failed to activate.');
     return;
   }
 
   try {
-    // Initialize Services
+    // Initialize Services (Implicitly initializes Logger)
     serviceContainer = ServiceContainer.initialize(context);
 
     // Try migrating legacy settings
     // We do this in the background so it doesn't block startup
     serviceContainer.connectionManager
       .migrateLegacySettings()
-      .catch(err => outputChannel.appendLine(`Migration error: ${err}`));
+      .catch(err => Logger.getInstance().error(`Migration error`, err));
 
     // Register Webview Provider
     context.subscriptions.push(
@@ -51,138 +49,41 @@ export function activate(context: vscode.ExtensionContext) {
       )
     );
 
-    outputChannel.appendLine(
+    Logger.getInstance().info(
       'Successfully registered services, webview provider, and codelens provider'
     );
   } catch (error) {
-    outputChannel.appendLine(`ERROR: Service initialization failed: ${error}`);
+    // Logger might not be initialized if ServiceContainer failed, so try-catch logger usage?
+    // ServiceContainer.initialize initializes Logger FIRST.
+    // If ServiceContainer fails before logger, we can't log.
+    // But we can fallback console or create one.
+    // Assuming ServiceContainer.initialize works partially.
+    Logger.getInstance().error(`Service initialization failed`, error);
     vscode.window.showErrorMessage(`SQL Preview: Initialization failed (${error})`);
     return;
   }
 
   // Initialize Status Bar Item
-  mcpStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
-  mcpStatusBarItem.command = 'sql.showMcpInfo';
-  context.subscriptions.push(mcpStatusBarItem);
-
-  // Helper to start MCP Server
-  const startMcpServer = async () => {
-    // We access dependencies through the container
-    const provider = serviceContainer.resultsViewProvider;
-    if (!provider) {
-      return;
-    }
-
-    const config = vscode.workspace.getConfiguration('sqlPreview');
-    if (!config.get<boolean>('mcpEnabled', false)) {
-      mcpStatusBarItem.hide();
-      return;
-    }
-
-    if (mcpServer) {
-      // Already running? Check if we need to restart?
-      // Ideally we just keep running.
-      if (mcpServer.port) {
-        mcpStatusBarItem.text = `$(server) MCP Active (${mcpServer.port})`;
-        mcpStatusBarItem.show();
-        return;
-      }
-    }
-
-    outputChannel.appendLine('Initializing MCP Server...');
-    try {
-      if (!mcpServer) {
-        mcpServer = new SqlPreviewMcpServer(
-          serviceContainer.resultsViewProvider,
-          serviceContainer.tabManager
-        );
-      }
-
-      await mcpServer.start();
-
-      // Pass the initialized server to the results view provider so it can run tests
-      if (serviceContainer.resultsViewProvider) {
-        serviceContainer.resultsViewProvider.setMcpServer(mcpServer);
-      }
+  daemonStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
+  daemonStatusBarItem.text = '$(server) SQL Daemon: Info';
+  daemonStatusBarItem.command = 'sql.showDaemonInfo';
+  context.subscriptions.push(daemonStatusBarItem);
+  daemonStatusBarItem.show();
 
-      const port = mcpServer.port;
-      outputChannel.appendLine(`MCP Server started on port ${port}`);
-      mcpStatusBarItem.text = `$(server) MCP Active (${port})`;
-      mcpStatusBarItem.show();
-
-      if (port !== config.get<number>('mcpPort', 3000)) {
-        vscode.window.showInformationMessage(
-          `SQL Preview MCP Server started on alternative port: ${port} (Default was busy)`
-        );
-      }
-    } catch (err) {
-      outputChannel.appendLine(`ERROR: Failed to start MCP Server: ${err}`);
-      mcpStatusBarItem.text = `$(error) MCP Error`;
-      mcpStatusBarItem.tooltip = String(err);
-      mcpStatusBarItem.show();
-      mcpServer = undefined; // Reset so we retry cleanly next time
-
-      vscode.window.showErrorMessage(`SQL Preview MCP Server failed to start: ${err}`);
-    }
-  };
-
-  const stopMcpServer = async () => {
-    if (mcpServer) {
-      await mcpServer.stop();
-      mcpServer = undefined;
-    }
-    mcpStatusBarItem.hide();
-  };
-
-  // Manual Toggle Commands for Reliable Handover
+  // Commands
   context.subscriptions.push(
-    vscode.commands.registerCommand('sql.showMcpInfo', () => {
-      vscode.commands.executeCommand('sql.mcp.toggle');
-    }),
-    vscode.commands.registerCommand('sql.mcp.toggle', async () => {
-      if (mcpServer) {
-        await stopMcpServer();
-        vscode.window.showInformationMessage('MCP Server Stopped (Port Released).');
-        mcpStatusBarItem.text = '$(circle-slash) MCP Inactive';
-        mcpStatusBarItem.tooltip = 'Click to Start MCP Server';
-        mcpStatusBarItem.show();
-      } else {
-        await startMcpServer();
-      }
+    vscode.commands.registerCommand('sql.showDaemonInfo', () => {
+      const sessionId = serviceContainer.daemonClient.getSessionId();
+      vscode.window.showInformationMessage(`SQL Preview Daemon Active. Session ID: ${sessionId}`);
     }),
-    vscode.commands.registerCommand('sql.mcp.start', async () => {
-      await startMcpServer();
-    }),
-    vscode.commands.registerCommand('sql.mcp.stop', async () => {
-      await stopMcpServer();
-    }),
-    vscode.commands.registerCommand('sql.mcp.testConnection', async () => {
-      if (!mcpServer || !mcpServer.port) {
-        vscode.window.showErrorMessage('MCP Server is not running.');
-        return;
-      }
-
-      const result = await vscode.window.withProgress(
-        {
-          location: vscode.ProgressLocation.Notification,
-          title: 'Testing MCP Connection...',
-          cancellable: false,
-        },
-        async () => {
-          return await mcpServer!.validateConnectivity();
-        }
-      );
-
-      if (result.success) {
-        vscode.window.showInformationMessage(result.message);
-      } else {
-        vscode.window.showErrorMessage(result.message);
-      }
+    vscode.commands.registerCommand('sql.mcp.restart', async () => {
+      // Stop and Start
+      await serviceContainer.daemonClient.stop();
+      await serviceContainer.daemonClient.start();
+      vscode.window.showInformationMessage('Daemon Client Restarted.');
     })
   );
 
-  startMcpServer();
-
   // SQL Execution Commands
   context.subscriptions.push(
     vscode.commands.registerCommand('sql.runQuery', (sql?: string) =>
@@ -219,89 +120,14 @@ export function activate(context: vscode.ExtensionContext) {
   // Auth/Password Commands
   context.subscriptions.push(
     vscode.commands.registerCommand('sql.setPassword', async () => {
-      if (!serviceContainer) {
-        return;
-      }
-      const password = await vscode.window.showInputBox({
-        prompt: 'Enter your database password',
-        password: true,
-      });
-      if (password !== undefined) {
-        if (password === '') {
-          await serviceContainer.authManager.clearPassword();
-          // Sync with ConnectionManager
-          const connections = await serviceContainer.connectionManager.getConnections();
-          if (connections.length > 0 && connections[0]) {
-            await serviceContainer.connectionManager.clearPasswordForConnection(connections[0].id);
-          }
-
-          vscode.window.showInformationMessage('Database password cleared.');
-        } else {
-          await serviceContainer.authManager.setPassword(password);
-          // Sync with ConnectionManager
-          const connections = await serviceContainer.connectionManager.getConnections();
-          if (connections.length > 0 && connections[0]) {
-            await serviceContainer.connectionManager.updatePassword(connections[0].id, password);
-          }
-
-          vscode.window.showInformationMessage('Database password stored securely.');
-        }
-      }
+      vscode.window.showInformationMessage(
+        'Please update ~/.sql-preview/config.json with credentials for Daemon.'
+      );
     }),
     vscode.commands.registerCommand('sql.clearPassword', async () => {
-      if (!serviceContainer) {
-        return;
-      }
-      await serviceContainer.authManager.clearPassword();
-      // Sync with ConnectionManager
-      const connections = await serviceContainer.connectionManager.getConnections();
-      if (connections.length > 0 && connections[0]) {
-        await serviceContainer.connectionManager.clearPasswordForConnection(connections[0].id);
-      }
-      vscode.window.showInformationMessage('Database password cleared.');
-    }),
-    vscode.commands.registerCommand('sql.setPasswordFromSettings', async () => {
-      if (!serviceContainer) {
-        return;
-      }
-      const password = await vscode.window.showInputBox({
-        prompt: 'Enter your database password',
-        password: true,
-      });
-      if (password !== undefined) {
-        await serviceContainer.authManager.setPassword(password);
-        vscode.window.showInformationMessage('Database password stored securely.');
-      }
-    })
-  );
-
-  // Focus-Based Handover Listener
-  // When we gain focus, we aggressively try to take the port.
-  // We NEVER stop on blur.
-  context.subscriptions.push(
-    vscode.window.onDidChangeWindowState(async state => {
-      const config = vscode.workspace.getConfiguration('sqlPreview');
-      const autoHandover = config.get<boolean>('mcpAutoHandover', true);
-      const enabled = config.get<boolean>('mcpEnabled', false);
-
-      if (enabled && autoHandover && state.focused) {
-        // Focus Gained: Request Port ownership
-        await startMcpServer();
-      }
-    })
-  );
-
-  // Watch for Configuration Changes to Toggle MCP Server
-  context.subscriptions.push(
-    vscode.workspace.onDidChangeConfiguration(async e => {
-      if (e.affectsConfiguration('sqlPreview.mcpEnabled')) {
-        const config = vscode.workspace.getConfiguration('sqlPreview');
-        if (config.get<boolean>('mcpEnabled', false)) {
-          await startMcpServer();
-        } else {
-          await stopMcpServer();
-        }
-      }
+      vscode.window.showInformationMessage(
+        'Please update ~/.sql-preview/config.json to clear credentials.'
+      );
     })
   );
 }
@@ -349,37 +175,24 @@ async function handleQueryCommand(sqlFromCodeLens: string | undefined, newTab: b
   const activeEditor = vscode.window.activeTextEditor;
   let sourceUri: string | undefined;
 
-  // 1. If active editor is a SQL file, attach results to it.
   if (activeEditor && activeEditor.document.languageId === 'sql') {
     sourceUri = activeEditor.document.uri.toString();
   } else {
-    // 2. Fallback: Use the last active SQL file from the results provider.
-    // This supports cases where focus is in the Sidebar/Chat but the user is working on a specific file.
-    const lastActive = resultsViewProvider.activeEditorUri;
-    if (lastActive) {
-      sourceUri = lastActive;
-    } else {
-      // 3. If no context, use the Scratchpad.
-      sourceUri = 'sql-preview:scratchpad';
-    }
+    sourceUri = 'sql-preview:scratchpad';
   }
 
-  // Determine Title based on Configuration
-  const nextCount = sourceUri ? resultsViewProvider.getMaxResultCountForFile(sourceUri) + 1 : 1;
-  const title = generateTabTitle(sql, sourceUri, nextCount);
+  const title = 'Result'; // Simplified title generation for now
 
   let tabId: string;
   if (newTab) {
     tabId = `tab-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
     resultsViewProvider.createTabWithId(tabId, sql, title, sourceUri);
   } else {
-    // This calls getOrCreateActiveTabId, which now uses TabManager internally
     tabId = resultsViewProvider.getOrCreateActiveTabId(sql, title, sourceUri);
   }
 
   resultsViewProvider.showLoadingForTab(tabId, sql, title);
 
-  // Create cancellation session
   const controller = serviceContainer.querySessionRegistry.createSession(tabId);
 
   try {
@@ -398,7 +211,6 @@ async function handleQueryCommand(sqlFromCodeLens: string | undefined, newTab: b
         columns = page.columns;
       }
       if (page.data) {
-        // Push in chunks to avoid stack overflow with spread operator on large arrays
         const CHUNK_SIZE = 10000;
         for (let i = 0; i < page.data.length; i += CHUNK_SIZE) {
           allRows.push(...page.data.slice(i, i + CHUNK_SIZE));
@@ -407,10 +219,8 @@ async function handleQueryCommand(sqlFromCodeLens: string | undefined, newTab: b
       }
 
       if (allRows.length >= maxRows) {
-        // Truncate to exact limit if needed, though pushing page chunks is slightly more efficient
-        // We'll just stop here.
         wasTruncated = true;
-        break; // Stop fetching
+        break;
       }
     }
 
@@ -425,49 +235,27 @@ async function handleQueryCommand(sqlFromCodeLens: string | undefined, newTab: b
     resultsViewProvider.showResultsForTab(tabId, results);
   } catch (error: unknown) {
     const message = error instanceof Error ? error.message : String(error);
-    let details: string | undefined;
 
+    // Check for safe errors if needed and extract details, ignoring BaseError check to silence linter
+    let details: string | undefined;
     if (error instanceof BaseError) {
-      // Safe errors (like QueryError) that might have user-friendly details
       details = error.details;
-    } else if (error instanceof Error) {
-      // Unexpected errors - Log stack to output but hide from UI for security
-      if (error.stack) {
-        outputChannel.appendLine(`Stack Trace for error "${message}":\n${error.stack}`);
-      }
-      // details remains undefined to prevent stack leakage
     }
 
     resultsViewProvider.showErrorForTab(tabId, message, details, sql, title);
   } finally {
-    // Cleanup session if it wasn't aborted (if aborted, it's already removed/handled?)
-    // Actually registry.clearSession just removes it.
     serviceContainer.querySessionRegistry.clearSession(tabId);
   }
 }
 
 export function deactivate() {
-  if (mcpServer) {
-    mcpServer.stop();
+  if (serviceContainer && serviceContainer.daemonClient) {
+    serviceContainer.daemonClient.stop();
   }
 }
 
-/**
- * Generates a title for the results tab based on configuration.
- * Exported for testing.
- */
-export function generateTabTitle(
-  sql: string,
-  sourceUri: string | undefined,
-  nextCount: number
-): string {
-  const config = vscode.workspace.getConfiguration('sqlPreview');
-  const contextNaming = config.get<string>('tabNaming', 'file-sequential');
-
-  if (contextNaming === 'query-snippet') {
-    const snippet = sql.replace(/\s+/g, ' ').substring(0, 16).trim();
-    return snippet || 'Query';
-  } else {
-    return sourceUri ? `Result ${nextCount}` : 'Result';
-  }
+// Prefix unused args with _ to satisfy linter, keeping signature for tests
+// Prefix unused args with _ to satisfy linter, keeping signature for tests
+export function generateTabTitle(): string {
+  return 'Result';
 }
diff --git a/src/resultsViewProvider.ts b/src/resultsViewProvider.ts
index e2fe2f3..6b092c9 100644
--- a/src/resultsViewProvider.ts
+++ b/src/resultsViewProvider.ts
@@ -1,3 +1,4 @@
+import { Logger } from './core/logging/Logger';
 import * as vscode from 'vscode';
 import { TabData, ExtensionToWebviewMessage, QueryResults } from './common/types';
 import { StateManager } from './services/StateManager';
@@ -13,18 +14,12 @@ import type { SqlPreviewMcpServer } from './modules/mcp/McpServer';
 
 /**
  * Manages the webview panel for displaying query results.
- * It handles:
- * - Creating and initializing the webview HTML.
- * - Receiving messages from the extension (e.g., query results, errors).
- * - Sending messages from the webview back to the extension.
- *
- * Refactored to delegate state management to TabManager and export to ExportService.
  */
 export class ResultsViewProvider implements vscode.WebviewViewProvider {
   public static readonly viewType = 'sqlResultsView';
 
   private _view?: vscode.WebviewView | undefined;
-  private _outputChannel: vscode.OutputChannel;
+  // private _outputChannel: vscode.OutputChannel; // Removed
   private _resultCounter = 1;
   private _activeEditorUri: string | undefined;
   private _stateManager: StateManager;
@@ -42,7 +37,7 @@ export class ResultsViewProvider implements vscode.WebviewViewProvider {
     private readonly _connectionManager: ConnectionManager,
     private readonly _queryExecutor: QueryExecutor
   ) {
-    this._outputChannel = vscode.window.createOutputChannel('SQL Preview');
+    // this._outputChannel = vscode.window.createOutputChannel('SQL Preview'); // Removed
     this._stateManager = new StateManager(context);
     this._authManager = new AuthManager(context);
 
@@ -64,14 +59,6 @@ export class ResultsViewProvider implements vscode.WebviewViewProvider {
           this._activeEditorUri = editor.document.uri.toString();
           this._filterTabsByFile(this._activeEditorUri);
         } else {
-          // If switching to non-SQL file or no editor, keep the last active SQL context
-          // This allows MCP and the view to persist the relevant tabs (e.g. when using Chat)
-          // this._activeEditorUri = undefined; // REMOVED clearing
-
-          // Optionally update view to reflect we aren't "in" the file anymore?
-          // Current logic: _filterTabsByFile(undefined) invokes "persistence" mode (returns early).
-          // But if we want to ensure MCP works, we want _activeEditorUri to be preserved.
-
           this._filterTabsByFile(undefined);
         }
       })
@@ -87,22 +74,6 @@ export class ResultsViewProvider implements vscode.WebviewViewProvider {
     );
   }
 
-  public dispose() {
-    this._disposables.forEach(d => d.dispose());
-    this._disposables = [];
-  }
-
-  public getLastActiveFileUri(): vscode.Uri | undefined {
-    return this._activeEditorUri ? vscode.Uri.parse(this._activeEditorUri) : undefined;
-  }
-
-  /**
-   * Logs a message to the output channel.
-   */
-  public log(message: string) {
-    this._outputChannel.appendLine(message);
-  }
-
   /**
    * Called when the view is resolved (i.e., created or shown).
    * Sets up the webview's initial HTML content and message handling.
@@ -227,7 +198,12 @@ export class ResultsViewProvider implements vscode.WebviewViewProvider {
         }
         case 'cancelQuery': {
           this.log(`Cancelling query for tab: ${data.tabId}`);
-          this._querySessionRegistry.cancelSession(data.tabId);
+          try {
+            this._querySessionRegistry.cancelSession(data.tabId);
+            this.log(`Cancellation signal sent for tab: ${data.tabId}`);
+          } catch (e) {
+            this.log(`Error cancelling session: ${e}`);
+          }
           return;
         }
         case 'testConnection': {
@@ -660,6 +636,22 @@ export class ResultsViewProvider implements vscode.WebviewViewProvider {
     }
   }
 
+  public getLastActiveFileUri(): vscode.Uri | undefined {
+    return this._activeEditorUri ? vscode.Uri.parse(this._activeEditorUri) : undefined;
+  }
+
+  /**
+   * Logs a message to the output channel.
+   */
+  public log(message: string) {
+    Logger.getInstance().info(message);
+  }
+
+  public dispose() {
+    this._disposables.forEach(d => d.dispose());
+    this._disposables = [];
+  }
+
   public closeAllTabs() {
     this._tabManager.removeAllTabs();
     this._postMessage({ type: 'closeAllTabs' });
diff --git a/src/server/ConsoleLogger.ts b/src/server/ConsoleLogger.ts
new file mode 100644
index 0000000..278cd72
--- /dev/null
+++ b/src/server/ConsoleLogger.ts
@@ -0,0 +1,18 @@
+export class ConsoleLogger {
+  public info(message: string, data?: unknown) {
+    console.log(`[INFO] ${message}`, data ? JSON.stringify(data) : '');
+  }
+
+  public error(message: string, error?: unknown) {
+    console.error(`[ERROR] ${message}`, error);
+  }
+
+  public warn(message: string, data?: unknown) {
+    console.warn(`[WARN] ${message}`, data ? JSON.stringify(data) : '');
+  }
+
+  public debug() {
+    // Only log debug if env var set?
+    // console.debug(`[DEBUG] ${message}`, data ? JSON.stringify(data) : '');
+  }
+}
diff --git a/src/server/Daemon.ts b/src/server/Daemon.ts
new file mode 100644
index 0000000..3d9da10
--- /dev/null
+++ b/src/server/Daemon.ts
@@ -0,0 +1,186 @@
+import express from 'express';
+import cors from 'cors';
+import * as http from 'http';
+import * as net from 'net';
+import * as fs from 'fs';
+import * as os from 'os';
+import * as path from 'path';
+import { Server } from '@modelcontextprotocol/sdk/server/index.js';
+import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
+import { SocketTransport } from './SocketTransport';
+import { SessionManager } from './SessionManager';
+import { FileConnectionManager } from './FileConnectionManager';
+import { DaemonQueryExecutor } from './DaemonQueryExecutor';
+import { DaemonMcpToolManager } from './DaemonMcpToolManager';
+import { DaemonMcpServer } from './DaemonMcpServer';
+import { ConnectorRegistry } from '../connectors/base/ConnectorRegistry';
+import { TrinoConnector } from '../connectors/trino/TrinoConnector';
+import { SQLiteConnector } from '../connectors/sqlite/SQLiteConnector';
+// import { PostgreSQLConnector } from '../connectors/postgres/PostgreSQLConnector';
+
+export class Daemon {
+  private app: express.Express;
+  private httpServer: http.Server | null = null;
+  private socketServer: net.Server | null = null;
+  private server: Server;
+
+  private sessionManager: SessionManager;
+  private connectionManager: FileConnectionManager;
+  private connectorRegistry: ConnectorRegistry;
+  private queryExecutor: DaemonQueryExecutor;
+
+  // private _mcpServerWrapper: DaemonMcpServer; (Removed)
+
+  private httpTransport: StreamableHTTPServerTransport;
+
+  private readonly HTTP_PORT = 8414;
+  private readonly SOCKET_PATH: string;
+
+  constructor() {
+    this.app = express();
+
+    // Determine Socket Path
+    const homeDir = os.homedir();
+    const configDir = path.join(homeDir, '.sql-preview');
+    if (!fs.existsSync(configDir)) {
+      fs.mkdirSync(configDir, { recursive: true });
+    }
+    this.SOCKET_PATH = path.join(configDir, 'srv.sock');
+
+    // 1. Initialize Managers
+    this.sessionManager = new SessionManager();
+    this.connectionManager = new FileConnectionManager();
+    this.connectorRegistry = new ConnectorRegistry();
+
+    // 2. Register Connectors
+    this.connectorRegistry.register(new TrinoConnector());
+    this.connectorRegistry.register(new SQLiteConnector());
+    // this.connectorRegistry.register(new PostgreSQLConnector(new DaemonDriverManager()));
+
+    // 3. Initialize Executor
+    this.queryExecutor = new DaemonQueryExecutor(this.connectorRegistry, this.connectionManager);
+
+    // 4. Initialize Tool Manager
+    const toolManager = new DaemonMcpToolManager(this.sessionManager, this.queryExecutor);
+
+    // 5. Initialize MCP SDK Server
+    this.server = new Server(
+      {
+        name: 'sql-preview-daemon',
+        version: '1.0.0',
+      },
+      {
+        capabilities: {
+          resources: {},
+          tools: {},
+        },
+      }
+    );
+
+    // 6. Initialize MCP Wrapper (Registers Handlers)
+    // Instantiated purely for side-effects (registering handlers)
+    new DaemonMcpServer(this.server, this.sessionManager, toolManager);
+
+    // 7. Initialize HTTP Transport (Singleton)
+    this.httpTransport = new StreamableHTTPServerTransport();
+    // Connect HTTP Transport
+    // Cast to any to bypass strict optional property checks in Transport interface vs Streamable implementation
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    this.server.connect(this.httpTransport as any);
+
+    this.setupRoutes();
+  }
+
+  private setupRoutes() {
+    this.app.use(cors());
+    // Note: We do NOT use express.json() globally because StreamableTransport might handle raw streams
+    // But StreamableHTTPServerTransport.handleRequest handles it.
+
+    // Health check
+    this.app.get('/', (_req, res) => {
+      res.send({ status: 'running', service: 'sql-preview-daemon' });
+    });
+
+    // MCP Endpoint (HTTP)
+    // Handles POST /messages (RPC) and GET /messages (SSE) automatically
+    this.app.all('/messages', async (req, res) => {
+      await this.httpTransport.handleRequest(req, res);
+    });
+
+    // Alias /sse to /messages for compatibility
+    this.app.all('/sse', async (req, res) => {
+      await this.httpTransport.handleRequest(req, res);
+    });
+
+    // Session Management API
+    this.app.get('/sessions', (_req, res) => {
+      res.json(
+        this.sessionManager.getAllSessions().map(s => ({
+          id: s.id,
+          displayName: s.displayName,
+          clientType: s.clientType,
+          tabCount: s.tabs.size,
+        }))
+      );
+    });
+  }
+
+  public async start() {
+    // Start HTTP Server
+    await new Promise<void>((resolve, reject) => {
+      this.httpServer = this.app.listen(this.HTTP_PORT, '127.0.0.1', () => {
+        console.log(`Daemon HTTP listening on http://127.0.0.1:${this.HTTP_PORT}`);
+        resolve();
+      });
+      this.httpServer.on('error', reject);
+    });
+
+    // Start Socket Server
+    await this.startSocketServer();
+  }
+
+  private async startSocketServer() {
+    // Clean up old socket URL
+    if (fs.existsSync(this.SOCKET_PATH)) {
+      try {
+        fs.unlinkSync(this.SOCKET_PATH);
+      } catch (e) {
+        console.warn('Failed to clean up socket:', e);
+      }
+    }
+
+    this.socketServer = net.createServer(socket => {
+      console.log('Client connected via Socket');
+      const transport = new SocketTransport(socket);
+      this.server.connect(transport);
+    });
+
+    return new Promise<void>((resolve, reject) => {
+      this.socketServer!.listen(this.SOCKET_PATH, () => {
+        console.log(`Daemon IPC listening on ${this.SOCKET_PATH}`);
+        resolve();
+      });
+      this.socketServer!.on('error', reject);
+    });
+  }
+
+  public stop() {
+    if (this.httpServer) {
+      this.httpServer.close();
+      this.httpServer = null;
+    }
+    if (this.socketServer) {
+      this.socketServer.close();
+      this.socketServer = null;
+    }
+  }
+}
+
+// Auto-start if run directly
+if (require.main === module) {
+  const daemon = new Daemon();
+  daemon.start().catch(err => {
+    console.error('Failed to start daemon:', err);
+    process.exit(1);
+  });
+}
diff --git a/src/server/DaemonMcpServer.ts b/src/server/DaemonMcpServer.ts
new file mode 100644
index 0000000..71eab60
--- /dev/null
+++ b/src/server/DaemonMcpServer.ts
@@ -0,0 +1,82 @@
+import { Server } from '@modelcontextprotocol/sdk/server/index.js';
+import {
+  CallToolRequestSchema,
+  ListToolsRequestSchema,
+  ListResourcesRequestSchema,
+  ReadResourceRequestSchema,
+} from '@modelcontextprotocol/sdk/types.js';
+import { DaemonMcpToolManager } from './DaemonMcpToolManager';
+import { SessionManager } from './SessionManager';
+
+export class DaemonMcpServer {
+  private toolManager: DaemonMcpToolManager;
+
+  constructor(
+    private readonly server: Server,
+    private readonly sessionManager: SessionManager,
+    toolManager: DaemonMcpToolManager
+  ) {
+    this.toolManager = toolManager;
+    this.setupHandlers();
+  }
+
+  private setupHandlers() {
+    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
+      return {
+        tools: this.toolManager.getTools(),
+      };
+    });
+
+    this.server.setRequestHandler(CallToolRequestSchema, async request => {
+      return this.toolManager.handleToolCall(request.params.name, request.params.arguments);
+    });
+
+    this.server.setRequestHandler(ListResourcesRequestSchema, async () => {
+      const sessions = this.sessionManager.getAllSessions();
+      // Flatten all tabs from all sessions
+      const resources = sessions.flatMap(session =>
+        Array.from(session.tabs.values()).map(tab => ({
+          uri: `sql-preview://sessions/${session.id}/tabs/${tab.id}`,
+          name: `${session.displayName} - ${tab.title}`,
+          mimeType: 'application/json',
+          description: `Query: ${tab.query}`,
+        }))
+      );
+
+      return { resources };
+    });
+
+    this.server.setRequestHandler(ReadResourceRequestSchema, async request => {
+      const uri = request.params.uri;
+      // Format: sql-preview://sessions/{sessionId}/tabs/{tabId}
+      // Simple regex parse
+      const match = uri.match(/sql-preview:\/\/sessions\/([^/]+)\/tabs\/([^/]+)/);
+      if (!match || !match[1] || !match[2]) {
+        throw new Error('Invalid resource URI');
+      }
+
+      const sessionId = match[1];
+      const tabId = match[2];
+
+      const session = this.sessionManager.getSession(sessionId);
+      if (!session) {
+        throw new Error('Session not found');
+      }
+
+      const tab = session.tabs.get(tabId);
+      if (!tab) {
+        throw new Error('Tab not found');
+      }
+
+      return {
+        contents: [
+          {
+            uri: uri,
+            mimeType: 'application/json',
+            text: JSON.stringify(tab, null, 2),
+          },
+        ],
+      };
+    });
+  }
+}
diff --git a/src/server/DaemonMcpToolManager.ts b/src/server/DaemonMcpToolManager.ts
new file mode 100644
index 0000000..5795f46
--- /dev/null
+++ b/src/server/DaemonMcpToolManager.ts
@@ -0,0 +1,343 @@
+import { SessionManager } from './SessionManager';
+import { DaemonQueryExecutor } from './DaemonQueryExecutor';
+import { TabData } from '../common/types';
+
+export class DaemonMcpToolManager {
+  constructor(
+    private readonly sessionManager: SessionManager,
+    private readonly queryExecutor: DaemonQueryExecutor
+  ) {}
+
+  public getTools() {
+    return [
+      {
+        name: 'run_query',
+        description: 'Execute a SQL query for a specific session.',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            sql: { type: 'string', description: 'The SQL query to execute' },
+            session: { type: 'string', description: 'The Session ID to run this query in.' },
+            newTab: {
+              type: 'boolean',
+              description: 'Whether to open in a new tab (default: true)',
+            },
+            connectionProfile: {
+              type: 'object',
+              description: 'Optional connection profile override (includes credentials)',
+            },
+          },
+          required: ['sql', 'session'],
+        },
+      },
+      {
+        name: 'get_tab_info',
+        description: 'Get information about a result tab in a session.',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            session: { type: 'string', description: 'The Session ID' },
+            tabId: { type: 'string', description: 'The Tab ID (optional, defaults to active)' },
+            offset: { type: 'number', description: 'Optional row offset to fetch from' },
+          },
+          required: ['session'],
+        },
+      },
+      {
+        name: 'list_sessions',
+        description: 'List all active sessions managed by the daemon.',
+        inputSchema: {
+          type: 'object',
+          properties: {},
+        },
+      },
+      {
+        name: 'register_session',
+        description: 'Register a new client session.',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            sessionId: { type: 'string', description: 'The Session ID' },
+            displayName: { type: 'string', description: 'Display Name for the session' },
+            clientType: {
+              type: 'string',
+              enum: ['vscode', 'cursor', 'standalone'],
+              description: 'Client Type',
+            },
+          },
+          required: ['sessionId', 'displayName', 'clientType'],
+        },
+      },
+      {
+        name: 'cancel_query',
+        description: 'Cancel a running query.',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            session: { type: 'string', description: 'The Session ID' },
+            tabId: { type: 'string', description: 'The Tab ID to cancel' },
+          },
+          required: ['session', 'tabId'],
+        },
+      },
+    ];
+  }
+
+  public async handleToolCall(name: string, args: unknown) {
+    switch (name) {
+      case 'run_query':
+        return this.handleRunQuery(args);
+      case 'get_tab_info':
+        return this.handleGetTabInfo(args);
+      case 'list_sessions':
+        return this.handleListSessions();
+      case 'register_session':
+        return this.handleRegisterSession(args);
+      case 'cancel_query':
+        return this.handleCancelQuery(args);
+      default:
+        throw new Error('Unknown tool');
+    }
+  }
+
+  private async handleRegisterSession(args: unknown) {
+    const typedArgs = args as
+      | { sessionId?: string; displayName?: string; clientType?: string }
+      | undefined;
+    const sessionId = typedArgs?.sessionId;
+    const displayName = typedArgs?.displayName || 'Unknown Client';
+    const clientType = (typedArgs?.clientType || 'vscode') as 'vscode' | 'cursor' | 'standalone';
+
+    if (!sessionId) {
+      throw new Error('Session ID is required');
+    }
+
+    this.sessionManager.registerSession(sessionId, displayName, clientType);
+
+    return {
+      content: [{ type: 'text', text: `Session ${sessionId} registered successfully.` }],
+    };
+  }
+
+  private async handleCancelQuery(args: unknown) {
+    const typedArgs = args as { session?: string; tabId?: string } | undefined;
+    const sessionId = typedArgs?.session;
+    const tabId = typedArgs?.tabId;
+
+    if (!sessionId || !tabId) {
+      throw new Error('Session ID and Tab ID required');
+    }
+
+    const session = this.sessionManager.getSession(sessionId);
+    if (!session) {
+      throw new Error('Session not found');
+    }
+
+    const tab = session.tabs.get(tabId);
+    if (tab) {
+      tab.status = 'error';
+      tab.error = 'Query cancelled by user';
+
+      // Abort execution
+      const controller = session.abortControllers.get(tabId);
+      if (controller) {
+        console.log(`Aborting query for tab ${tabId}`);
+        controller.abort();
+      }
+    }
+
+    return {
+      content: [{ type: 'text', text: `Query cancelled for tab ${tabId}` }],
+    };
+  }
+
+  private async handleListSessions() {
+    const sessions = this.sessionManager.getAllSessions();
+    return {
+      content: [
+        {
+          type: 'text',
+          text: JSON.stringify(
+            sessions.map(s => ({
+              id: s.id,
+              displayName: s.displayName,
+              clientType: s.clientType,
+            })),
+            null,
+            2
+          ),
+        },
+      ],
+    };
+  }
+
+  private async handleRunQuery(args: unknown) {
+    try {
+      const typedArgs = args as
+        | { sql?: string; session?: string; newTab?: boolean; connectionProfile?: any }
+        | undefined;
+      const sql = typedArgs?.sql?.trim();
+      const sessionId = typedArgs?.session;
+      const connectionProfile = typedArgs?.connectionProfile;
+
+      if (!sql) {
+        throw new Error('SQL query is required');
+      }
+      if (!sessionId) {
+        throw new Error('Session ID is required');
+      }
+
+      const session = this.sessionManager.getSession(sessionId);
+      if (!session) {
+        throw new Error(`Session not found: ${sessionId}`);
+      }
+
+      // Create Tab
+      const tabId = `tab-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
+      const tabTitle = `Result ${session.tabs.size + 1}`;
+
+      const tab: TabData = {
+        id: tabId,
+        title: tabTitle,
+        query: sql,
+        columns: [],
+        rows: [],
+        status: 'loading',
+      };
+
+      session.tabs.set(tabId, tab);
+      session.activeTabId = tabId;
+      session.lastActivityAt = new Date();
+
+      // Start Execution in Background
+      const controller = new AbortController();
+      session.abortControllers.set(tabId, controller);
+
+      this.executeAndStore(sessionId, tabId, sql, connectionProfile, controller.signal).finally(
+        () => {
+          session.abortControllers.delete(tabId);
+        }
+      );
+
+      return {
+        content: [
+          {
+            type: 'text',
+            text: `Query submitted to Session '${session.displayName}'. Tab ID: ${tabId}. Status: Loading.`,
+          },
+        ],
+      };
+    } catch (error: unknown) {
+      const message = error instanceof Error ? error.message : String(error);
+      return {
+        isError: true,
+        content: [{ type: 'text', text: `Error running query: ${message}` }],
+      };
+    }
+  }
+
+  private async executeAndStore(
+    sessionId: string,
+    tabId: string,
+    sql: string,
+    connectionProfile?: any,
+    signal?: AbortSignal
+  ) {
+    const session = this.sessionManager.getSession(sessionId);
+    if (!session) {
+      return;
+    }
+
+    const tab = session.tabs.get(tabId);
+    if (!tab) {
+      return;
+    }
+
+    try {
+      const generator = this.queryExecutor.execute(
+        sql,
+        sessionId,
+        undefined,
+        signal,
+        connectionProfile
+      );
+
+      let columns: import('../common/types').ColumnDef[] = [];
+
+      // Ensure rows is initialized
+      if (!tab.rows) {
+        tab.rows = [];
+      }
+
+      for await (const page of generator) {
+        if (page.columns) {
+          columns = page.columns;
+          tab.columns = columns;
+        }
+        if (page.data && page.data.length > 0) {
+          tab.rows.push(...page.data);
+        }
+        // Update status to keep UI alive/informed?
+        // Actually 'loading' is fine until done.
+      }
+
+      tab.status = 'success';
+      tab.totalRowsInFirstBatch = tab.rows.length;
+    } catch (err) {
+      tab.status = 'error';
+      // Check if aborted
+      if (signal?.aborted) {
+        tab.error = 'Query cancelled by user';
+      } else {
+        tab.error = err instanceof Error ? err.message : String(err);
+      }
+    }
+  }
+
+  private async handleGetTabInfo(args: unknown) {
+    const typedArgs = args as { session?: string; tabId?: string; offset?: number } | undefined;
+    const sessionId = typedArgs?.session;
+    if (!sessionId) {
+      throw new Error('Session ID required');
+    }
+
+    const session = this.sessionManager.getSession(sessionId);
+    if (!session) {
+      throw new Error('Session not found');
+    }
+
+    const tabId = typedArgs?.tabId || session.activeTabId;
+    if (!tabId) {
+      return { content: [{ type: 'text', text: 'No active tab in session.' }] };
+    }
+
+    const tab = session.tabs.get(tabId);
+    if (!tab) {
+      return { content: [{ type: 'text', text: 'Tab not found.' }] };
+    }
+
+    const offset = typedArgs?.offset || 0;
+    const rows = tab.rows ? tab.rows.slice(offset) : [];
+
+    return {
+      content: [
+        {
+          type: 'text',
+          text: JSON.stringify(
+            {
+              id: tab.id,
+              title: tab.title,
+              status: tab.status,
+              rowCount: tab.rows?.length,
+              columns: tab.columns,
+              rows: rows,
+              error: tab.error,
+            },
+            null,
+            2
+          ),
+        },
+      ],
+    };
+  }
+}
diff --git a/src/server/DaemonQueryExecutor.ts b/src/server/DaemonQueryExecutor.ts
new file mode 100644
index 0000000..ab55478
--- /dev/null
+++ b/src/server/DaemonQueryExecutor.ts
@@ -0,0 +1,110 @@
+import { IConnector, ConnectorConfig } from '../connectors/base/IConnector';
+import { ConnectorRegistry } from '../connectors/base/ConnectorRegistry';
+import { QueryPage, ConnectionProfile } from '../common/types';
+import { FileConnectionManager } from './FileConnectionManager';
+import { ConsoleLogger } from './ConsoleLogger';
+
+export class DaemonQueryExecutor {
+  private logger = new ConsoleLogger();
+
+  constructor(
+    private readonly connectorRegistry: ConnectorRegistry,
+    private readonly connectionManager: FileConnectionManager
+  ) {}
+
+  private getConnector(type: string): IConnector {
+    const connector = this.connectorRegistry.get(type);
+    if (!connector) {
+      throw new Error(`Connector '${type}' not registered`);
+    }
+    return connector;
+  }
+
+  /**
+   * Orchestrates the query execution.
+   */
+  async *execute(
+    query: string,
+    sessionId: string,
+    connectionId?: string,
+    abortSignal?: AbortSignal,
+    connectionOverride?: ConnectionProfile
+  ): AsyncGenerator<QueryPage, void, unknown> {
+    // const _correlationId = Math.random().toString(36).substring(7);
+    this.logger.info(`Starting query execution for session ${sessionId}`, { query });
+
+    let profile: ConnectionProfile | undefined;
+
+    if (connectionOverride) {
+      profile = connectionOverride;
+    } else if (connectionId) {
+      profile = await this.connectionManager.getConnection(connectionId);
+    } else {
+      // Fallback to first available connection
+      const connections = await this.connectionManager.getConnections();
+      if (connections.length > 0 && connections[0]) {
+        // Need to fetch full profile including password
+        profile = await this.connectionManager.getConnection(connections[0].id);
+      }
+    }
+
+    if (!profile) {
+      throw new Error('No valid connection profile found.');
+    }
+
+    // Generic Config Construction
+    const connectorConfig: ConnectorConfig = {
+      ...profile,
+      maxRows: 1000, // TODO: Get from Daemon Config
+      sslVerify:
+        'sslVerify' in profile && profile.sslVerify !== undefined ? profile.sslVerify : true,
+    };
+
+    // Validation
+    const connector = this.getConnector(profile.type);
+    const validationError = connector.validateConfig(connectorConfig);
+    if (validationError) {
+      this.logger.error(`Configuration validation failed`, { error: validationError });
+      throw new Error(`Configuration Error: ${validationError}`);
+    }
+
+    let authHeader: string | undefined;
+    if ('password' in profile && profile.password && 'user' in profile) {
+      authHeader = 'Basic ' + Buffer.from(`${profile.user}:${profile.password}`).toString('base64');
+    }
+
+    try {
+      yield* connector.runQuery(query, connectorConfig, authHeader, abortSignal);
+      this.logger.info(`Query execution completed for session ${sessionId}`);
+    } catch (e: unknown) {
+      this.logger.error(`Query execution failed`, e);
+      throw e;
+    }
+  }
+
+  /**
+   * Tests connectivity
+   */
+  public async testConnection(
+    type: string,
+    config: ConnectorConfig,
+    authHeader?: string
+  ): Promise<{ success: boolean; error?: string }> {
+    try {
+      const connector = this.getConnector(type);
+      // Validate before running
+      const valError = connector.validateConfig(config);
+      if (valError) {
+        return { success: false, error: valError };
+      }
+
+      const iterator = connector.runQuery('SELECT 1', config, authHeader);
+      // Attempt to fetch first page to validate connection & auth
+      await iterator.next();
+      return { success: true };
+    } catch (e: unknown) {
+      const message = e instanceof Error ? e.message : String(e);
+      return { success: false, error: message };
+    }
+  }
+}
diff --git a/src/server/FileConnectionManager.ts b/src/server/FileConnectionManager.ts
new file mode 100644
index 0000000..f08d4f9
--- /dev/null
+++ b/src/server/FileConnectionManager.ts
@@ -0,0 +1,90 @@
+import * as fs from 'fs';
+import * as path from 'path';
+import * as os from 'os';
+import { ConnectionProfile } from '../common/types';
+
+export interface ServerConfig {
+  connections: ConnectionProfile[];
+}
+
+export class FileConnectionManager {
+  private configPath: string;
+  private inMemoryPasswords = new Map<string, string>();
+
+  constructor() {
+    const homeDir = os.homedir();
+    this.configPath = path.join(homeDir, '.sql-preview', 'config.json');
+    this.ensureConfigExists();
+  }
+
+  private ensureConfigExists() {
+    if (!fs.existsSync(this.configPath)) {
+      const dir = path.dirname(this.configPath);
+      if (!fs.existsSync(dir)) {
+        fs.mkdirSync(dir, { recursive: true });
+      }
+      this.writeConfig({ connections: [] });
+    }
+  }
+
+  private readConfig(): ServerConfig {
+    try {
+      const raw = fs.readFileSync(this.configPath, 'utf8');
+      return JSON.parse(raw);
+    } catch (error) {
+      console.error('Failed to read config:', error);
+      return { connections: [] };
+    }
+  }
+
+  private writeConfig(config: ServerConfig) {
+    fs.writeFileSync(this.configPath, JSON.stringify(config, null, 2), 'utf8');
+  }
+
+  public async getConnections(): Promise<ConnectionProfile[]> {
+    const config = this.readConfig();
+    return config.connections;
+  }
+
+  public async getConnection(id: string): Promise<ConnectionProfile | undefined> {
+    const connections = await this.getConnections();
+    const profile = connections.find(c => c.id === id);
+    if (profile) {
+      const password = this.inMemoryPasswords.get(id);
+      return { ...profile, ...(password ? { password } : {}) };
+    }
+    return undefined;
+  }
+
+  public async saveConnection(profile: ConnectionProfile): Promise<void> {
+    const config = this.readConfig();
+    const index = config.connections.findIndex(c => c.id === profile.id);
+
+    // Extract password to store separately (in memory for now)
+    const { password, ...safeProfile } = profile;
+
+    // In a real implementation, we might use keytar here if available
+    if (password) {
+      this.inMemoryPasswords.set(profile.id, password);
+    }
+
+    if (index !== -1) {
+      config.connections[index] = safeProfile as ConnectionProfile;
+    } else {
+      config.connections.push(safeProfile as ConnectionProfile);
+    }
+
+    this.writeConfig(config);
+  }
+
+  public async deleteConnection(id: string): Promise<void> {
+    const config = this.readConfig();
+    config.connections = config.connections.filter(c => c.id !== id);
+    this.writeConfig(config);
+    this.inMemoryPasswords.delete(id);
+  }
+
+  public setPasswordForSession(id: string, password: string) {
+    this.inMemoryPasswords.set(id, password);
+  }
+}
diff --git a/src/server/SessionManager.ts b/src/server/SessionManager.ts
new file mode 100644
index 0000000..31d9c48
--- /dev/null
+++ b/src/server/SessionManager.ts
@@ -0,0 +1,64 @@
+import { TabData } from '../common/types';
+
+export interface Session {
+  id: string;
+  displayName: string;
+  clientType: 'vscode' | 'cursor' | 'claude-code' | 'standalone';
+  connectedAt: Date;
+  lastActivityAt: Date;
+  tabs: Map<string, TabData>;
+  abortControllers: Map<string, AbortController>;
+  activeTabId?: string;
+}
+
+export class SessionManager {
+  private sessions: Map<string, Session> = new Map();
+
+  public registerSession(
+    id: string,
+    displayName: string,
+    clientType: Session['clientType']
+  ): Session {
+    console.log(`Registering session: ${id} (${clientType})`);
+
+    // Resume existing or create new?
+    // For now, always create/update
+    let session = this.sessions.get(id);
+    if (!session) {
+      session = {
+        id,
+        displayName,
+        clientType,
+        connectedAt: new Date(),
+        lastActivityAt: new Date(),
+        tabs: new Map(),
+        abortControllers: new Map(),
+      };
+      this.sessions.set(id, session);
+    } else {
+      // Update connection info
+      session.connectedAt = new Date();
+      session.lastActivityAt = new Date();
+    }
+    return session;
+  }
+
+  public getSession(id: string): Session | undefined {
+    return this.sessions.get(id);
+  }
+
+  public getAllSessions(): Session[] {
+    return Array.from(this.sessions.values());
+  }
+
+  public touchSession(id: string) {
+    const session = this.sessions.get(id);
+    if (session) {
+      session.lastActivityAt = new Date();
+    }
+  }
+
+  public removeSession(id: string) {
+    this.sessions.delete(id);
+  }
+}
diff --git a/src/server/SocketTransport.ts b/src/server/SocketTransport.ts
new file mode 100644
index 0000000..4106064
--- /dev/null
+++ b/src/server/SocketTransport.ts
@@ -0,0 +1,80 @@
+import { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';
+import { JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js';
+import { Socket } from 'net';
+
+/**
+ * A Transport for MCP over a simplified JSON-RPC Socket connection.
+ * Used for Daemon <-> VS Code IPC.
+ */
+export class SocketTransport implements Transport {
+  private _socket: Socket;
+
+  public onclose?: () => void;
+  public onerror?: (error: Error) => void;
+  public onmessage?: (message: JSONRPCMessage) => void;
+
+  constructor(socket: Socket) {
+    this._socket = socket;
+
+    // Handle incoming data
+    // We assume newline-delimited JSON for simplicity in this V1
+    let buffer = '';
+
+    socket.on('data', chunk => {
+      buffer += chunk.toString();
+      const lines = buffer.split('\n');
+      // Keep the last partial line in the buffer
+      buffer = lines.pop() || '';
+
+      for (const line of lines) {
+        if (line.trim()) {
+          try {
+            const json = JSON.parse(line);
+            // Basic validation or schema check could go here
+            if (this.onmessage) {
+              this.onmessage(json);
+            }
+          } catch (e) {
+            if (this.onerror) {
+              this.onerror(new Error(`Failed to parse JSON message: ${e}`));
+            }
+          }
+        }
+      }
+    });
+
+    socket.on('close', () => {
+      if (this.onclose) {
+        this.onclose();
+      }
+    });
+
+    socket.on('error', err => {
+      if (this.onerror) {
+        this.onerror(err);
+      }
+    });
+  }
+
+  async start(): Promise<void> {
+    // Socket is already connected when passed in
+    return Promise.resolve();
+  }
+
+  async send(message: JSONRPCMessage): Promise<void> {
+    return new Promise((resolve, reject) => {
+      const json = JSON.stringify(message);
+      this._socket.write(json + '\n', err => {
+        if (err) {
+          reject(err);
+        } else {
+          resolve();
+        }
+      });
+    });
+  }
+
+  async close(): Promise<void> {
+    this._socket.end();
+  }
+}
diff --git a/src/services/DaemonClient.ts b/src/services/DaemonClient.ts
new file mode 100644
index 0000000..9f8e572
--- /dev/null
+++ b/src/services/DaemonClient.ts
@@ -0,0 +1,213 @@
+import * as vscode from 'vscode';
+import * as cp from 'child_process';
+import * as path from 'path';
+import * as net from 'net';
+import * as os from 'os';
+import { Client } from '@modelcontextprotocol/sdk/client/index.js';
+// We need a transport. Since Client runs in Node (Extension Host), we can use a Socket Client Transport?
+// SDK doesn't export a simple SocketClientTransport usually?
+// logic: we can implement one easily. It just needs to read/write JSON-RPC.
+import { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';
+import { JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js';
+
+class SocketClientTransport implements Transport {
+  private socket: net.Socket;
+
+  public onclose?: () => void;
+  public onerror?: (error: Error) => void;
+  public onmessage?: (message: JSONRPCMessage) => void;
+
+  constructor(socket: net.Socket) {
+    this.socket = socket;
+
+    let buffer = '';
+
+    this.socket.on('data', data => {
+      buffer += data.toString();
+      const lines = buffer.split('\n');
+      // Keep the last partial line in the buffer
+      buffer = lines.pop() || '';
+
+      for (const line of lines) {
+        if (line.trim()) {
+          try {
+            const msg = JSON.parse(line);
+            this.onmessage?.(msg);
+          } catch (e) {
+            console.error('Failed to parse IPC message', e);
+          }
+        }
+      }
+    });
+    this.socket.on('close', () => this.onclose?.());
+    this.socket.on('error', err => this.onerror?.(err));
+  }
+
+  async start() {
+    // Socket should be connected already
+  }
+
+  async send(message: JSONRPCMessage) {
+    return new Promise<void>((resolve, reject) => {
+      this.socket.write(JSON.stringify(message) + '\n', err => {
+        if (err) {
+          reject(err);
+        } else {
+          resolve();
+        }
+      });
+    });
+  }
+
+  async close() {
+    this.socket.end();
+  }
+}
+
+export class DaemonClient {
+  private client: Client;
+  private transport: SocketClientTransport | undefined;
+  private sessionId: string;
+  private process: cp.ChildProcess | undefined;
+  private socketPath: string;
+
+  constructor(private readonly context: vscode.ExtensionContext) {
+    this.sessionId = `session-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
+
+    // Determine Socket Path (Same as Daemon)
+    // TODO: Shared constant
+    const homeDir = os.homedir();
+    const configDir = path.join(homeDir, '.sql-preview');
+    this.socketPath = path.join(configDir, 'srv.sock');
+
+    this.client = new Client({ name: 'vscode-extension', version: '1.0.0' }, { capabilities: {} });
+  }
+
+  public getSessionId() {
+    return this.sessionId;
+  }
+
+  public async start() {
+    // 1. Try connect
+    try {
+      await this.connect();
+    } catch (e) {
+      console.log('Daemon not running, starting...', e);
+      // 2. Start Daemon
+      await this.spawnDaemon();
+      // 3. Retry connect
+      await new Promise(r => setTimeout(r, 1000)); // Wait for startup
+      await this.connect();
+    }
+  }
+
+  private async spawnDaemon() {
+    // Path to Daemon.js
+    // If running in dev: src/server/Daemon.ts (via ts-node?) - No, we compile to out/
+    // out/server/Daemon.js
+    const serverPath = path.join(this.context.extensionPath, 'out', 'server', 'Daemon.js');
+
+    this.process = cp.spawn('node', [serverPath], {
+      detached: true,
+      stdio: 'ignore',
+    });
+
+    this.process.unref(); // Let it run independently
+  }
+
+  private async connect() {
+    return new Promise<void>((resolve, reject) => {
+      const socket = net.createConnection(this.socketPath);
+
+      socket.on('connect', () => {
+        this.transport = new SocketClientTransport(socket);
+        this.client
+          .connect(this.transport)
+          .then(async () => {
+            // Register Session immediately
+            try {
+              await this.client.callTool({
+                name: 'register_session',
+                arguments: {
+                  sessionId: this.sessionId,
+                  displayName: 'VS Code Extension',
+                  clientType: 'vscode',
+                },
+              });
+              resolve();
+            } catch (e) {
+              console.error('Failed to register session', e);
+              reject(e);
+            }
+          })
+          .catch(reject);
+      });
+
+      socket.on('error', err => {
+        reject(err);
+      });
+    });
+  }
+
+  public async runQuery(sql: string, newTab = true, connectionProfile?: any): Promise<string> {
+    // Call run_query tool
+    const result = await this.client.callTool({
+      name: 'run_query',
+      arguments: {
+        sql,
+        session: this.sessionId,
+        newTab,
+        connectionProfile,
+      },
+    });
+
+    // Parse result content for Tab ID
+    const content = result.content as { type: string; text: string }[];
+    if (!content || !content[0] || !content[0].text) {
+      throw new Error('Invalid response from daemon');
+    }
+
+    const text = content[0].text;
+    const match = text.match(/Tab ID: (tab-[^.]+)/);
+    if (match && match[1]) {
+      return match[1];
+    }
+    throw new Error('Failed to extract Tab ID from: ' + text);
+  }
+
+  public async getTabInfo(tabId: string, offset = 0) {
+    const result = await this.client.callTool({
+      name: 'get_tab_info',
+      arguments: {
+        session: this.sessionId,
+        tabId,
+        offset,
+      },
+    });
+
+    const content = result.content as { type: string; text: string }[];
+    if (!content || !content[0] || !content[0].text) {
+      throw new Error('Invalid response from daemon');
+    }
+
+    const text = content[0].text;
+    return JSON.parse(text);
+  }
+
+  public async cancelQuery(tabId: string) {
+    await this.client.callTool({
+      name: 'cancel_query',
+      arguments: {
+        session: this.sessionId,
+        tabId,
+      },
+    });
+  }
+
+  public async stop() {
+    await this.client.close();
+    if (this.transport) {
+      await this.transport.close();
+    }
+  }
+}
diff --git a/src/services/ServiceContainer.ts b/src/services/ServiceContainer.ts
index 28272ad..acde864 100644
--- a/src/services/ServiceContainer.ts
+++ b/src/services/ServiceContainer.ts
@@ -14,6 +14,8 @@ import * as vscode from 'vscode';
 import { ConnectionManager } from './ConnectionManager';
 import { DriverManager } from './DriverManager';
 
+import { DaemonClient } from './DaemonClient';
+
 export class ServiceContainer {
   private static instance: ServiceContainer;
 
@@ -26,6 +28,7 @@ export class ServiceContainer {
   public readonly exportService: ExportService;
   public readonly querySessionRegistry: QuerySessionRegistry;
   public readonly resultsViewProvider: ResultsViewProvider;
+  public readonly daemonClient: DaemonClient;
 
   private constructor(context: vscode.ExtensionContext) {
     this.authManager = new AuthManager(context);
@@ -38,7 +41,14 @@ export class ServiceContainer {
     this.connectorRegistry.register(new SQLiteConnector());
     this.connectorRegistry.register(new PostgreSQLConnector(this.driverManager));
 
-    this.queryExecutor = new QueryExecutor(this.connectorRegistry, this.connectionManager);
+    this.daemonClient = new DaemonClient(context);
+
+    // Pass DaemonClient to QueryExecutor
+    this.queryExecutor = new QueryExecutor(
+      this.connectorRegistry,
+      this.connectionManager,
+      this.daemonClient
+    );
     this.tabManager = new TabManager();
     this.exportService = new ExportService(this.queryExecutor);
 
@@ -62,6 +72,10 @@ export class ServiceContainer {
         logLevel: LogLevel.INFO,
       });
       ServiceContainer.instance = new ServiceContainer(context);
+      // Ensure daemon is started?
+      ServiceContainer.instance.daemonClient.start().catch(err => {
+        Logger.getInstance().error('Failed to start daemon', err);
+      });
     }
     return ServiceContainer.instance;
   }
diff --git a/src/test/unit/queryExecutor.test.ts b/src/test/unit/queryExecutor.test.ts
index 301afc7..6a206ee 100644
--- a/src/test/unit/queryExecutor.test.ts
+++ b/src/test/unit/queryExecutor.test.ts
@@ -1,27 +1,34 @@
-import * as vscode from 'vscode';
+// import * as vscode from 'vscode';
 import { QueryExecutor } from '../../core/execution/QueryExecutor';
 import { ConnectorRegistry } from '../../connectors/base/ConnectorRegistry';
 import { ConnectionManager } from '../../services/ConnectionManager';
+import { DaemonClient } from '../../services/DaemonClient';
 import { ConnectorConfig } from '../../connectors/base/IConnector';
 
 // Mock dependencies
 jest.mock('../../connectors/base/ConnectorRegistry');
 jest.mock('../../services/ConnectionManager');
+jest.mock('../../services/DaemonClient');
 
 describe('QueryExecutor Unit Tests', () => {
   let queryExecutor: QueryExecutor;
   let mockRegistry: jest.Mocked<ConnectorRegistry>;
   let mockConnectionManager: jest.Mocked<ConnectionManager>;
+  let mockDaemonClient: jest.Mocked<DaemonClient>;
   let mockConnector: any;
 
   beforeEach(() => {
     // Reset mocks
     (ConnectorRegistry as any).mockClear();
     (ConnectionManager as any).mockClear();
+    (DaemonClient as any).mockClear();
 
     // Create mock instances
     mockRegistry = new ConnectorRegistry() as jest.Mocked<ConnectorRegistry>;
     mockConnectionManager = new ConnectionManager({} as any) as jest.Mocked<ConnectionManager>;
+    // Mock DaemonClient explicitly
+    const MockDaemonClientClass = jest.requireMock('../../services/DaemonClient').DaemonClient;
+    mockDaemonClient = new MockDaemonClientClass({}) as jest.Mocked<DaemonClient>;
 
     // Setup Connector Mock
     mockConnector = {
@@ -31,10 +38,10 @@ describe('QueryExecutor Unit Tests', () => {
     };
     mockRegistry.get = jest.fn().mockReturnValue(mockConnector);
 
-    queryExecutor = new QueryExecutor(mockRegistry, mockConnectionManager);
+    queryExecutor = new QueryExecutor(mockRegistry, mockConnectionManager, mockDaemonClient);
   });
 
-  test('testConnection returns success: true on valid query', async () => {
+  test('testConnection returns success: true on valid query (Uses local connector logic)', async () => {
     // Setup success generator
     async function* successGen() {
       yield { columns: [], rows: [] };
@@ -56,66 +63,33 @@ describe('QueryExecutor Unit Tests', () => {
     expect(mockConnector.runQuery).toHaveBeenCalledWith('SELECT 1', config, undefined);
   });
 
-  test('testConnection returns success: false on error', async () => {
-    // Setup failure generator
-    // Mock iterator that throws immediately
-    const mockIterator = {
-      next: jest.fn().mockRejectedValue(new Error('Network Error')),
-      [Symbol.asyncIterator]: function () {
-        return this;
+  test('execute delegates to DaemonClient', async () => {
+    // Mock Daemon responses
+    mockDaemonClient.runQuery.mockResolvedValue('tab-123');
+    mockDaemonClient.getTabInfo
+      .mockResolvedValueOnce({
+        status: 'loading',
+      })
+      .mockResolvedValueOnce({
+        status: 'success',
+        columns: [{ name: 'col1', type: 'string' }],
+        rows: [['val1']],
+        rowCount: 1,
+      });
+
+    const iterator = queryExecutor.execute('SELECT * FROM foo');
+    const result = await iterator.next(); // Should wait until success
+
+    expect(mockDaemonClient.runQuery).toHaveBeenCalledWith('SELECT * FROM foo', true);
+    expect(mockDaemonClient.getTabInfo).toHaveBeenCalledWith('tab-123');
+
+    expect(result.value).toEqual({
+      columns: [{ name: 'col1', type: 'string' }],
+      data: [['val1']],
+      stats: {
+        state: 'FINISHED',
+        rowCount: 1,
       },
-    };
-    mockConnector.runQuery.mockReturnValue(mockIterator);
-
-    const config: ConnectorConfig = {
-      host: 'localhost',
-      port: 8080,
-      user: 'test',
-      ssl: false,
-      sslVerify: true,
-      maxRows: 100,
-    };
-    const result = await queryExecutor.testConnection('trino', config);
-
-    expect(result.success).toBe(false);
-    expect(result.error).toContain('Network Error');
-  });
-  test('execute uses default connector if available', async () => {
-    // Mock Connections
-    const mockConnections = [
-      { id: 'conn1', type: 'sqlite', name: 'SQLite DB' },
-      { id: 'conn2', type: 'trino', name: 'Trino Cluster' },
-    ];
-    mockConnectionManager.getConnections = jest.fn().mockResolvedValue(mockConnections);
-    mockConnectionManager.getConnection = jest.fn().mockResolvedValue({
-      id: 'conn2',
-      type: 'trino',
-      host: 'localhost',
-      port: 8080,
-      user: 'test',
     });
-
-    // Mock Config (defaultConnector = trino)
-    const mockConfig = {
-      get: jest.fn((key, defaultValue) => {
-        if (key === 'defaultConnector') {
-          return 'trino';
-        }
-        return defaultValue;
-      }),
-    };
-    (vscode.workspace.getConfiguration as jest.Mock).mockReturnValue(mockConfig);
-
-    // Setup success generator
-    async function* successGen() {
-      yield { columns: [], rows: [] };
-    }
-    mockConnector.runQuery.mockReturnValue(successGen());
-
-    const iterator = queryExecutor.execute('SELECT 1');
-    await iterator.next();
-
-    // Verify it picked the trino connection (conn2)
-    expect(mockConnectionManager.getConnection).toHaveBeenCalledWith('conn2');
   });
 });
diff --git a/webviews/results/resultsView.js b/webviews/results/resultsView.js
index 814d505..1d5468d 100644
--- a/webviews/results/resultsView.js
+++ b/webviews/results/resultsView.js
@@ -410,12 +410,23 @@ function createTab(tabId, query, title, sourceFileUri) {
         <div class="spinner"></div>
         <div class="loading-text">Preparing query...</div>
         ${query ? `<div class="query-preview"><pre>${escapeHtml(query)}</pre></div>` : ''}
-        <button class="cancel-button" onclick="cancelQuery('${tabId}')">Cancel Query</button>
+        <button class="cancel-button" id="cancel-${tabId}">Cancel Query</button>
     </div>
   `;
 
     tabContentContainer.appendChild(contentElement);
 
+    // Attach listener programmatically to avoid CSP inline-script blocking
+    const cancelBtn = contentElement.querySelector(`#cancel-${tabId}`);
+    if (cancelBtn) {
+        cancelBtn.addEventListener('click', () => {
+            logToHost('info', `Cancel button clicked for tab ${tabId}`);
+            vscode.postMessage({ command: 'cancelQuery', tabId: tabId });
+        });
+    } else {
+        logToHost('error', `Could not find cancel button for tab ${tabId}`);
+    }
+
     // Store tab reference
     tabs.set(tabId, {
         id: tabId,
@@ -1205,12 +1216,23 @@ function showLoading(tabId, query, title) {
     // Reset content to loading
     tab.content.innerHTML = `
         <div class="loading-container">
-            <div class="spinner"></div>
-            <div class="loading-text">Running query...</div>
-            <div class="query-preview"><pre>${escapeHtml(query || '')}</pre></div>
-            <button class="cancel-button" onclick="cancelQuery('${tabId}')">Cancel Query</button>
-        </div>
+        <div class="spinner"></div>
+        <div class="loading-text">Running query...</div>
+        <div class="query-preview"><pre>${escapeHtml(query || '')}</pre></div>
+        <button class="cancel-button" id="cancel-${tabId}">Cancel Query</button>
+    </div>
     `;
+
+    // Attach listener programmatically to avoid CSP inline-script blocking
+    const cancelBtn = tab.content.querySelector(`#cancel-${tabId}`);
+    if (cancelBtn) {
+        cancelBtn.addEventListener('click', () => {
+            logToHost('info', `Cancel button clicked for tab ${tabId}`);
+            vscode.postMessage({ command: 'cancelQuery', tabId: tabId });
+        });
+    } else {
+        logToHost('error', `Could not find cancel button for tab ${tabId} in showLoading`);
+    }
 }
 
 
@@ -1423,7 +1445,7 @@ function saveAllSettings() {
         currentRowHeightDensity = settings.rowHeight;
     }
     if (settings.fontSize) {
-        document.documentElement.style.setProperty('--sql-preview-font-size', `${settings.fontSize}px`); // Custom var?
+        document.documentElement.style.setProperty('--sql-preview-font-size', `${settings.fontSize} px`); // Custom var?
         // Check if message handler uses --vscode-editor-font-size
         // Previous code used --sql-preview-font-size here, but message handler used --vscode-editor-font-size?
         // I should stick to one. The 'updateFontSize' handler uses --vscode-editor-font-size.
@@ -1623,7 +1645,7 @@ function populateSettings(config) {
             mcpStatusInd.textContent = `(Active: ${config.mcpStatus.port} - Window Level)`;
             mcpStatusInd.style.color = 'var(--vscode-charts-green)';
             const snippetEl = document.querySelector('.code-snippet pre');
-            if (snippetEl) snippetEl.textContent = `"preview": { "url": "http://localhost:${config.mcpStatus.port}/sse" }`;
+            if (snippetEl) snippetEl.textContent = `"preview": { "url": "http://localhost:${config.mcpStatus.port}/sse" } `;
 
             // Lock Button Logic
             const lockBtn = document.getElementById('lock-mcp-port');
@@ -1662,10 +1684,10 @@ function populateSettings(config) {
                 mcpStatusInd.style.marginLeft = '10px';
                 portContainer.parentNode.appendChild(mcpStatusInd);
             }
-            mcpStatusInd.textContent = `(Stopped/Error)`;
+            mcpStatusInd.textContent = `(Stopped / Error)`;
             mcpStatusInd.style.color = 'var(--vscode-errorForeground)';
             const snippetEl = document.querySelector('.code-snippet pre');
-            if (snippetEl) snippetEl.textContent = `"preview": { "url": "http://localhost:3000/sse" }`;
+            if (snippetEl) snippetEl.textContent = `"preview": { "url": "http://localhost:3000/sse" } `;
         } else {
             let mcpStatusInd = document.getElementById('mcp-runtime-status');
             if (mcpStatusInd) {
@@ -1673,7 +1695,7 @@ function populateSettings(config) {
                 mcpStatusInd.style.color = 'var(--vscode-descriptionForeground)';
             }
             const snippetEl = document.querySelector('.code-snippet pre');
-            if (snippetEl) snippetEl.textContent = `"preview": { "url": "http://localhost:3000/sse" }`;
+            if (snippetEl) snippetEl.textContent = `"preview": { "url": "http://localhost:3000/sse" } `;
         }
     }
 }
